<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>e-mulate API documentation</title>
<meta name="description" content="e-mulate
This is the main script of the e-mulate software." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>e-mulate</code></h1>
</header>
<section id="section-intro">
<p>e-mulate
This is the main script of the e-mulate software.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
e-mulate
This is the main script of the e-mulate software.
&#34;&#34;&#34;
# Qt5
from code import interact
from PyQt5 import uic
from PyQt5.QtCore import Qt, QTimer, pyqtSignal
from PyQt5.QtGui import QPixmap, QIcon
from PyQt5.QtWidgets import (
    QAbstractItemView,
    QApplication,
    QFileDialog,
    QMainWindow,
    QSplashScreen,
    QTableWidgetItem,
    QWidget,
)

QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)  # enable highdpi scaling
QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps, True)  # use highdpi icons

# To deal with files, time, paths...
import configparser
from copy import deepcopy

# from multiprocessing import cpu_count
import numpy as np
import os

# from pathos.multiprocessing import ProcessingPool as Pool
import pickle
import sys
import time
import webbrowser

import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas

# Toolbar shown on the figures
from matplotlib.backends.backend_qt5 import NavigationToolbar2QT as NavigationToolbar

# Changes to rcParams are system-wide, so at the end of the program, the defaults need
# to be reset
from matplotlib import rcParams

# Guarantees that every part of the figure is inside the canvas
rcParams.update({&#34;figure.autolayout&#34;: True})

# File containing the main class
import simdata
import interface_config

# Adding the GUI files directory to the system path
sys.path.append(os.path.join(os.path.dirname(__file__), &#34;GUI&#34;))

NM = 1.0e-9


class MainWindow(QMainWindow):
    &#34;&#34;&#34;
    Main window
    &#34;&#34;&#34;

    def __init__(self, parent=None):
        &#34;&#34;&#34;
        Initialization of the main window
        &#34;&#34;&#34;
        super(MainWindow, self).__init__(parent)
        # Loads the ui
        self.base_path = os.path.dirname(os.path.realpath(__file__))
        uic.loadUi(
            os.path.join(self.base_path, &#34;GUI&#34;, &#34;TM_tabs.ui&#34;),
            self,
        )
        # Sets the window icon
        self.setWindowIcon(
            QIcon(
                os.path.join(
                    self.base_path,
                    &#34;Imagens&#34;,
                    &#34;favicon.ico&#34;,
                )
            )
        )

        # Reads the configuration file and create the corresponding variables
        self.mat = configparser.ConfigParser()
        self.mat.read(os.path.join(self.base_path, &#34;materials.data&#34;))

        # Creating the list containing all simulations
        self.sim_list = []
        # Stores the number of the current simulation
        self.current_number = 1

        self.ConnectSignals()
        # Calls an auxiliary script that contains interface configuration functions
        interface_config.run(self)
        self.CreatePlots()
        self.InitializeStructTable()
        self.InitializeDataTable()
        self.UpdateInterface()

    # GUI ##############################################################################
    def ConnectSignals(self):
        &#34;&#34;&#34;
        Connect the signals from buttons to functions.
        Disables any button that should only be enabled after a new simulation is
        created.
        &#34;&#34;&#34;
        # Lower bar
        # self.new_btn.clicked.connect(self.new_sim_window.show)
        self.new_btn.clicked.connect(self.OpenNewSimWindow)
        self.save_btn.clicked.connect(self.SaveSimulation)
        self.load_btn.clicked.connect(self.LoadSimulation)
        self.delete_btn.clicked.connect(self.DeleteSimulation)
        self.output_folder_btn.clicked.connect(self.ChooseOutputFolder)
        self.simulation_cbox.currentIndexChanged.connect(self.UpdateInterface)
        self.rename_btn.clicked.connect(self.RenameSimulation)
        self.copy_btn.clicked.connect(self.CopySimulation)

        # Design tab
        self.add_well_btn.clicked.connect(lambda: self.UpdateStructure(&#34;AddWell&#34;))
        self.add_barrier_btn.clicked.connect(lambda: self.UpdateStructure(&#34;AddBarrier&#34;))
        self.replace_well_btn.clicked.connect(
            lambda: self.UpdateStructure(&#34;ReplaceWell&#34;)
        )
        self.replace_barrier_btn.clicked.connect(
            lambda: self.UpdateStructure(&#34;ReplaceBarrier&#34;)
        )
        self.insert_well_btn.clicked.connect(lambda: self.UpdateStructure(&#34;InsertWell&#34;))
        self.insert_barrier_btn.clicked.connect(
            lambda: self.UpdateStructure(&#34;InsertBarrier&#34;)
        )
        self.remove_selected_btn.clicked.connect(
            lambda: self.UpdateStructure(&#34;RemoveSelected&#34;)
        )
        self.remove_last_btn.clicked.connect(lambda: self.UpdateStructure(&#34;RemoveLast&#34;))
        self.remove_all_btn.clicked.connect(lambda: self.UpdateStructure(&#34;RemoveAll&#34;))
        self.well_ml_spb.valueChanged.connect(self.UpdateUnits)
        self.well_nm_spb.valueChanged.connect(self.UpdateUnits)
        self.barrier_ml_spb.valueChanged.connect(self.UpdateUnits)
        self.barrier_nm_spb.valueChanged.connect(self.UpdateUnits)

        # Simulation tab
        self.sim_Efield_btn.clicked.connect(self.Campo)
        # Electric field button and spinbox are disabled because they don&#39;t work
        self.sim_Efield_btn.setEnabled(False)
        self.sim_Efield_spb.setEnabled(False)
        self.sim_run_btn.clicked.connect(lambda: self.RunSimulation())
        self.sim_plot_results_btn.clicked.connect(lambda: self.PlotSimResults())
        self.sim_plot_structure_btn.clicked.connect(lambda: self.PlotStructure())
        self.sim_clear_plot_btn.clicked.connect(self.ClearSimPlot)
        self.sim_dx_ml_spb.valueChanged.connect(self.UpdateUnits)
        self.sim_dx_nm_spb.valueChanged.connect(self.UpdateUnits)
        self.sim_central_layer_spb.valueChanged.connect(lambda: self.PlotStructure())

        # Absorption tab
        self.abs_run_btn.clicked.connect(lambda: self.RunAbsorption())
        self.abs_plot_btn.clicked.connect(lambda: self.PlotAbsorption())
        self.abs_clear_plot_btn.clicked.connect(self.ClearAbsPlot)

        # Transmission tab
        self.tra_run_btn.clicked.connect(lambda: self.RunTransmission())
        self.tra_plot_btn.clicked.connect(lambda: self.PlotTransmission())
        self.tra_clear_plot_btn.clicked.connect(lambda: self.ClearTransPlot())

        # Photocurrent tab
        self.pc_run_btn.clicked.connect(lambda: self.RunPhotocurrent())
        self.pc_clear_plot_btn.clicked.connect(lambda: self.ClearPhotocurrentPlot())

        # GA tab
        # self.ga_btn.clicked.connect(self.Sobre)

        # Automation tab
        self.auto_run_btn.clicked.connect(self.RunAutomation)

        # Advanced options tab
        self.adv_nm_layers_chkbx.stateChanged.connect(self.UpdateUnits)
        self.adv_save_gui_config.clicked.connect(self.SaveGUIConfigFile)

        # Actions from menus
        # File Menu
        # self.action_new.triggered.connect(self.NewSimulation)
        self.action_new.triggered.connect(self.OpenNewSimWindow)
        self.action_load.triggered.connect(self.LoadSimulation)
        self.action_save.triggered.connect(self.SaveSimulation)
        self.action_exit.triggered.connect(exit)
        # Help Menu
        self.action_about.triggered.connect(self.Sobre)

    def UpdateUnits(self):
        &#34;&#34;&#34;
        This function is used to update the layer thickness spinboxes, making sure that
        the value in nm corresponds an integer multiple of the lattice parameter,
        defined by the monolayer&#39;s spinboxes, and vice versa.
        This routine is divided in two parts (by the try-except), things that can be
        determined before creating a simulation and the ones that depend on the lattice
        parameter.
        &#34;&#34;&#34;
        # If the user prefers to use nanometers instead of monolayers:
        if self.adv_nm_layers_chkbx.checkState():
            # Changes the suffix of the spinboxes
            self.auto_step_spb.setSuffix(&#34; nm&#34;)
            self.auto_final_spb.setSuffix(&#34; nm&#34;)
            self.auto_init_spb.setSuffix(&#34; nm&#34;)
        else:  # If the user is using monolayers
            # Changes the suffix of the spinboxes
            self.auto_step_spb.setSuffix(&#34; ML&#34;)
            self.auto_final_spb.setSuffix(&#34; ML&#34;)
            self.auto_init_spb.setSuffix(&#34; ML&#34;)

        # The lattice parameter is only defined after a simulation was created.
        try:  # Gets the current simulation and the value of the lattice parameter
            sim = self.sim_list[self.simulation_cbox.currentIndex()]
            ml = sim.latpar / 2.0
        except:
            return

        # Identifies which spinbox was modified (the one which called this function)
        op = self.sender()

        # If the user prefers to use nanometers instead of monolayers:
        if self.adv_nm_layers_chkbx.checkState():
            # Disable the ml spinboxes, so that the user cannot interact with them
            self.barrier_ml_spb.setEnabled(False)
            self.well_ml_spb.setEnabled(False)
            self.sim_dx_ml_spb.setEnabled(False)
            # Enable the nm spinboxes
            self.barrier_nm_spb.setEnabled(True)
            self.well_nm_spb.setEnabled(True)
            self.sim_dx_nm_spb.setEnabled(True)

            # Set the value of the monolayers spinboxes, base on the nm values (converted to meters)
            # if op == self.barrier_nm_spb:
            self.barrier_ml_spb.setValue(
                np.round(self.barrier_nm_spb.value() * NM / ml, 3)
            )
            # if op == self.well_nm_spb:
            self.well_ml_spb.setValue(np.round(self.well_nm_spb.value() * NM / ml, 3))
            self.sim_dx_ml_spb.setValue(
                np.round(self.sim_dx_nm_spb.value() * NM / ml, 3)
            )

        # If the user is using monolayers
        else:
            # Enable the ml spinboxes, so that the user can interact with them
            self.barrier_ml_spb.setEnabled(True)
            self.well_ml_spb.setEnabled(True)
            self.sim_dx_ml_spb.setEnabled(True)
            # Disable the nm spinboxes
            self.barrier_nm_spb.setEnabled(False)
            self.well_nm_spb.setEnabled(False)
            self.sim_dx_nm_spb.setEnabled(False)
            # if op == self.barrier_ml_spb:
            # lp is in meters, converts to nm
            self.barrier_nm_spb.setValue(self.barrier_ml_spb.value() * ml / NM)
            # if op == self.well_ml_spb:
            self.well_nm_spb.setValue(self.well_ml_spb.value() * ml / NM)
            self.sim_dx_nm_spb.setValue(self.sim_dx_ml_spb.value() * ml / NM)

    def CreatedNewSimulation(self):
        &#34;&#34;&#34;
        Called after a new simulation is created, just to update the interface
        &#34;&#34;&#34;
        self.simulation_cbox.setCurrentIndex(len(self.sim_list) - 1)
        # Defines the output folder based on the simulation title
        sim = self.sim_list[
            -1
        ]  # The new simulation was just appended to the end of the list
        sim.output_folder = str(self.output_folder_line.text())
        self.PlotStructure()
        self.UpdateStructureTable()
        self.UpdateSimList()
        self.UpdateInterface()
        self.UpdateLayerCount()
        self.UpdateUnits()

    def UpdateSimList(self):
        &#34;&#34;&#34;
        If simulations are added, deleted or loaded, needs to update the list
        &#34;&#34;&#34;
        # Clears the simulation list
        self.simulation_cbox.clear()
        # Fills the simulation combobox with every simulation from the list
        for sim in self.sim_list:
            self.simulation_cbox.addItem(sim.title)
        self.simulation_cbox.setCurrentIndex(len(self.sim_list) - 1)

    def UpdateStructure(self, op):
        &#34;&#34;&#34;
        Function that adds, inserts or removes layers from the surface, based on the user choice on
        the GUI.
        op is the operation the user wants to perform, defined in self.ConnectSignals
        &#34;&#34;&#34;
        sim = self.sim_list[self.simulation_cbox.currentIndex()]

        # Adding a new well
        if op == &#34;AddWell&#34;:
            sim.AddWell(self.well_nm_spb.value())

        # Adding a new barrier
        elif op == &#34;AddBarrier&#34;:
            sim.AddBarrier(self.barrier_nm_spb.value())

        # Replacing a well
        elif op == &#34;ReplaceWell&#34;:
            index = self.struct_table.currentRow()  # Selected table line
            if index == -1:  # In case there is nothing to replace
                return
            sim.ReplaceWell(self.well_nm_spb.value(), index)

        # Replacing a barrier
        elif op == &#34;ReplaceBarrier&#34;:
            index = self.struct_table.currentRow()  # Selected table line
            if index == -1:  # In case there is nothing to replace
                return
            sim.ReplaceBarrier(self.barrier_nm_spb.value(), index)

        # Inserting a well
        elif op == &#34;InsertWell&#34;:
            index = self.struct_table.currentRow()  # Selected table line
            sim.InsertWell(self.well_nm_spb.value(), index)

        # Inserting a barrier
        elif op == &#34;InsertBarrier&#34;:
            index = self.struct_table.currentRow()  # Selected table line
            sim.InsertBarrier(self.barrier_nm_spb.value(), index)

        elif op == &#34;RemoveSelected&#34;:
            index = self.struct_table.currentRow()  # Linha da tabela selecionada
            if len(sim.estrutura) &gt; 1:  # If there is a structure, delete the last item
                sim.RemoveSelected(index)
            else:
                op = &#34;RemoveAll&#34;  # Just to avoid repeating 5 lines of code

        elif op == &#34;RemoveLast&#34;:
            if len(sim.estrutura) &gt; 1:  # If there is a structure, delete the last item
                sim.RemoveSelected(-1)
            else:
                op = &#34;RemoveAll&#34;  # Just to avoid repeating 5 lines of code

        # This is not &#34;elif&#34; just so that the &#34;else&#34; from RemoveSelected and RemoveLast work
        if op == &#34;RemoveAll&#34;:
            sim.RemoveAll()

        # Since the structure was modified, define this simulation as not ran
        sim.sim_ran = False
        sim.abs_ran = False

        # Updates table, graph and buttons
        self.UpdateStructureTable()
        self.PlotStructure(sim)
        self.UpdateInterface()
        self.UpdateLayerCount()

    def UpdateLayerCount(self):
        &#34;&#34;&#34;
        Calculates the number of layers and updates the Spinbox on the advanced tab
        &#34;&#34;&#34;

        try:  # If there is a simulation and this simulation has at least one layer
            sim = self.sim_list[self.simulation_cbox.currentIndex()]
            layers = len(sim.estrutura)
            self.adv_total_layers_spb.setValue(layers)
        except:  # If there is no simulation or it doesn&#39;t have any layers yet
            self.adv_total_layers_spb.setValue(0)

    def UpdateInterface(self):
        &#34;&#34;&#34;
        Updates the buttons, list of simulations available on the simulations combobox.
        This simulation is called almost everytime after user interaction.
        &#34;&#34;&#34;
        # Check whether there are simulations
        # The selected simulation defines whether some options on the interface are available
        # If there are no simulations, disable most buttons, except &#34;load&#34; and &#34;new&#34;
        if len(self.sim_list) == 0:
            # Lower bar
            self.save_btn.setEnabled(False)
            self.delete_btn.setEnabled(False)
            self.copy_btn.setEnabled(False)
            self.rename_btn.setEnabled(False)
            self.output_folder_btn.setEnabled(False)
            # Structure tab
            self.add_well_btn.setEnabled(False)
            self.add_barrier_btn.setEnabled(False)
            self.replace_well_btn.setEnabled(False)
            self.replace_barrier_btn.setEnabled(False)
            self.insert_well_btn.setEnabled(False)
            self.insert_barrier_btn.setEnabled(False)
            self.remove_selected_btn.setEnabled(False)
            self.remove_last_btn.setEnabled(False)
            self.remove_all_btn.setEnabled(False)
            # Layer thickness spinboxes
            self.barrier_ml_spb.setEnabled(False)
            self.well_ml_spb.setEnabled(False)
            self.barrier_nm_spb.setEnabled(False)
            self.well_nm_spb.setEnabled(False)
            # Simulation tab
            self.sim_Efield_btn.setEnabled(False)
            self.sim_run_btn.setEnabled(False)
            self.sim_plot_results_btn.setEnabled(False)
            self.sim_plot_structure_btn.setEnabled(False)
            # Absorption tab
            self.abs_run_btn.setEnabled(False)
            self.abs_plot_btn.setEnabled(False)
            # Transmission tab
            self.tra_plot_btn.setEnabled(False)
            # Photocurrent tab
            self.pc_run_btn.setEnabled(False)
            # Genetic algorithm tab
            self.ga_run_btn.setEnabled(False)
            # Automation tab
            self.auto_run_btn.setEnabled(False)

            self.ClearStructureTable()
            self.ClearSimPlot()
            self.ClearAbsPlot()
            self.ClearMaterialData()

        else:
            # current simulation
            sim = self.sim_list[self.simulation_cbox.currentIndex()]
            # If there are available simulations, some buttons must to be enabled
            # Lower bar
            self.save_btn.setEnabled(True)
            self.delete_btn.setEnabled(True)
            self.copy_btn.setEnabled(True)
            self.rename_btn.setEnabled(True)
            self.output_folder_btn.setEnabled(True)
            # Structure tab
            self.add_well_btn.setEnabled(True)
            self.add_barrier_btn.setEnabled(True)
            self.insert_well_btn.setEnabled(True)
            self.insert_barrier_btn.setEnabled(True)
            # Layer thickness spinboxes
            if self.adv_nm_layers_chkbx.checkState():
                self.barrier_nm_spb.setEnabled(True)
                self.well_nm_spb.setEnabled(True)
            else:
                self.barrier_ml_spb.setEnabled(True)
                self.well_ml_spb.setEnabled(True)

            if (
                len(sim.estrutura) &gt; 0
            ):  # If the structure is has layers, a simulation may be run
                # Simulation tab
                self.sim_run_btn.setEnabled(True)
                self.sim_plot_structure_btn.setEnabled(True)
                # Structure tab
                self.replace_well_btn.setEnabled(True)
                self.replace_barrier_btn.setEnabled(True)
                self.remove_selected_btn.setEnabled(True)
                self.remove_last_btn.setEnabled(True)
                self.remove_all_btn.setEnabled(True)
                # Genetic algorithm tab
                self.ga_run_btn.setEnabled(True)
                # Automation tab
                self.auto_run_btn.setEnabled(True)

                if sim.sim_ran is False:  # If the simulation has not yet been executed
                    # Simulation tab
                    self.sim_plot_results_btn.setEnabled(False)
                    # Absorption tab
                    self.abs_run_btn.setEnabled(False)
                    # Transmission tab
                    self.tra_plot_btn.setEnabled(False)
                    # Photocurrent tab
                    self.pc_run_btn.setEnabled(False)
                else:
                    # Simulation tab
                    self.sim_plot_results_btn.setEnabled(True)
                    # Absorption tab
                    self.abs_run_btn.setEnabled(True)
                    # Transmission tab
                    self.tra_plot_btn.setEnabled(True)
                    # Photocurrent tab
                    self.pc_run_btn.setEnabled(True)

                if (
                    sim.abs_ran is False
                ):  # If the absorption has not yet been calculated
                    self.abs_plot_btn.setEnabled(False)
                else:
                    self.abs_plot_btn.setEnabled(True)
            else:
                # Simulation tab
                self.sim_run_btn.setEnabled(False)
                # Structure tab
                self.replace_well_btn.setEnabled(False)
                self.replace_barrier_btn.setEnabled(False)
                self.remove_selected_btn.setEnabled(False)
                self.remove_last_btn.setEnabled(False)
                self.remove_all_btn.setEnabled(False)
                # Simulation tab
                self.sim_Efield_btn.setEnabled(False)
                self.sim_plot_results_btn.setEnabled(False)
                self.sim_plot_structure_btn.setEnabled(False)
                # Absorption tab
                self.abs_run_btn.setEnabled(False)
                # Genetic algorithm tab
                self.ga_run_btn.setEnabled(False)
                # Automation tab
                self.auto_run_btn.setEnabled(False)
            self.UpdateStructureTable()
            self.FillMaterialData()

    # Information about the materials used on the simulation, shown on the structure tab
    def ClearMaterialData(self):
        &#34;&#34;&#34;
        Removes the information about the materials from the Structure Tab. This
        function is called when there is no simulation.
        &#34;&#34;&#34;
        self.lbl_lattice_parameter_val.setText(&#34;&#34;)
        self.lbl_barrier_material_val.setText(&#34;&#34;)
        self.lbl_barrier_effective_mass_val.setText(&#34;&#34;)
        self.lbl_barrier_electronic_potential_val.setText(&#34;&#34;)
        self.lbl_barrier_non_parabolicity_val.setText(&#34;&#34;)
        self.lbl_well_material_val.setText(&#34;&#34;)
        self.lbl_well_effective_mass_val.setText(&#34;&#34;)
        self.lbl_well_electronic_potential_val.setText(&#34;&#34;)
        self.lbl_well_non_parabolicity_val.setText(&#34;&#34;)

    def FillMaterialData(self):
        &#34;&#34;&#34;
        Fills the structure tab with data for the selected materials.
        &#34;&#34;&#34;
        sim = self.sim_list[self.simulation_cbox.currentIndex()]
        self.lbl_lattice_parameter_val.setText(f&#34;{1E10*sim.latpar:.3f} Ang&#34;)
        self.lbl_barrier_material_val.setText(f&#34;{sim.barrier}&#34;)
        self.lbl_barrier_effective_mass_val.setText(f&#34;{sim.m_eff_ct_barrier:.3e}&#34;)
        self.lbl_barrier_electronic_potential_val.setText(
            f&#34;{1E3*sim.pot_barrier:.2f} meV&#34;
        )
        self.lbl_barrier_non_parabolicity_val.setText(f&#34;{sim.e_nonparab_barrier:.3e}&#34;)
        self.lbl_well_material_val.setText(f&#34;{sim.well}&#34;)
        self.lbl_well_effective_mass_val.setText(f&#34;{sim.m_eff_ct_well:.3e}&#34;)
        self.lbl_well_electronic_potential_val.setText(f&#34;{1E3*sim.pot_well:.2f} meV&#34;)
        self.lbl_well_non_parabolicity_val.setText(f&#34;{sim.e_nonparab_well:.3e}&#34;)

    # Tables ###########################################################################
    # Structure
    def InitializeStructTable(self):
        &#34;&#34;&#34;
        Initializes the table presenting the structure
        &#34;&#34;&#34;
        self.struct_table.setColumnCount(4)
        self.struct_table.setColumnWidth(0, 60)
        self.struct_table.setColumnWidth(1, 60)
        self.struct_table.setColumnWidth(2, 40)
        self.struct_table.setColumnWidth(3, 40)
        self.struct_table.move(0, 0)
        self.struct_table.setHorizontalHeaderLabels([&#34;Material&#34;, &#34;Feature&#34;, &#34;ML&#34;, &#34;nm&#34;])
        self.struct_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.struct_table.setSelectionBehavior(QAbstractItemView.SelectRows)

    def UpdateStructureTable(self):
        &#34;&#34;&#34;
        Function that updates the table at the structure tab. The table is erased every time and
        rewrites it all again usig information from sim.material and sim.estrutura.
        &#34;&#34;&#34;
        sim = self.sim_list[self.simulation_cbox.currentIndex()]
        self.struct_table.setRowCount(len(sim.material))
        for i, material in enumerate(sim.material):
            col0 = QTableWidgetItem(material)  # Creates the item
            col0.setTextAlignment(0x0084)  # Align h center, v baseline
            col1 = QTableWidgetItem(sim.feature[i])
            col1.setTextAlignment(0x0084)  # Align h center, v baseline
            col2 = QTableWidgetItem(f&#34;{sim.estrutura[i] / ( sim.latpar / 2):.0f}&#34;)
            col2.setTextAlignment(0x0082)  # Align h right, v baseline
            col3 = QTableWidgetItem(f&#34;{sim.estrutura[i] / NM:.3f}&#34;)
            col3.setTextAlignment(0x0082)  # Align h right, v baseline
            self.struct_table.setItem(i, 0, col0)
            self.struct_table.setItem(i, 1, col1)
            self.struct_table.setItem(i, 2, col2)
            self.struct_table.setItem(i, 3, col3)
            # Adjusts the line heigth
            self.struct_table.setRowHeight(i, 18)
            # Corrects the line index (without this correction, it starts from 1, instead of 0)
            self.struct_table.setVerticalHeaderItem(i, QTableWidgetItem(f&#34;{i}&#34;))
        # Adjusts the column width
        self.struct_table.setColumnWidth(0, 60)
        self.struct_table.setColumnWidth(1, 60)
        self.struct_table.setColumnWidth(2, 40)
        self.struct_table.setColumnWidth(3, 40)

    def ClearStructureTable(self):
        self.struct_table.setRowCount(0)

    # Simulation data
    def InitializeDataTable(self):
        &#34;&#34;&#34;
        Initializes the table presenting the results
        &#34;&#34;&#34;
        self.data_table.setColumnCount(1)
        self.data_table.setColumnWidth(0, 120)
        # self.struct_table.setColumnWidth(1, 60)
        # self.struct_table.setColumnWidth(2, 40)
        # self.struct_table.setColumnWidth(3, 40)
        self.data_table.move(0, 0)
        # Definition of the header labels
        h_lbls = [&#34;Energy (meV)&#34;]
        self.data_table.setHorizontalHeaderLabels(h_lbls)
        self.data_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.data_table.setSelectionBehavior(QAbstractItemView.SelectRows)

    def UpdateDataTable(self):
        &#34;&#34;&#34;
        Function that updates the table at the data tab. The table is erased every time and
        rewritten with data from the latest simulation
        &#34;&#34;&#34;
        self.ClearDataTable()
        # Gets the current selected simulation
        sim = self.sim_list[self.simulation_cbox.currentIndex()]

        self.data_table.setRowCount(len(sim.sim_Energias))
        for i, energia in enumerate(sim.sim_Energias):

            col0 = QTableWidgetItem(f&#34;{energia * 1000:.3f} meV&#34;)  # Creates the item
            col0.setTextAlignment(0x0084)  # Align h center, v baseline
            # col1 = QTableWidgetItem(sim.feature[i])
            # col1.setTextAlignment(0x0084)  # Align h center, v baseline
            # col2 = QTableWidgetItem(f&#34;{sim.estrutura[i] / ( sim.latpar / 2):.0f}&#34;)
            # col2.setTextAlignment(0x0082)  # Align h right, v baseline
            # col3 = QTableWidgetItem(f&#34;{sim.estrutura[i] / NM:.3f}&#34;)
            # col3.setTextAlignment(0x0082)  # Align h right, v baseline
            self.data_table.setItem(i, 0, col0)
            # self.struct_table.setItem(i, 1, col1)
            # self.struct_table.setItem(i, 2, col2)
            # self.struct_table.setItem(i, 3, col3)
            # Adjusts the line heigth
            self.data_table.setRowHeight(i, 18)
            # Corrects the line index (without this correction, it starts from 1, instead of 0)
            self.data_table.setVerticalHeaderItem(i, QTableWidgetItem(f&#34;{i}&#34;))
        # Adjusts the column width
        self.data_table.setColumnWidth(0, 120)
        # self.struct_table.setColumnWidth(1, 60)
        # self.struct_table.setColumnWidth(2, 40)
        # self.struct_table.setColumnWidth(3, 40)

    def ClearDataTable(self):
        self.data_table.setRowCount(0)

    # Plots ############################################################################
    def CreatePlots(self):
        &#34;&#34;&#34;
        Initial configuration of the plots
        &#34;&#34;&#34;
        # Simulation
        self.sim_fig = plt.figure()
        self.sim_canvas = FigureCanvas(self.sim_fig)
        self.sim_plot_layout.addWidget(self.sim_canvas)
        self.sim_nav = NavigationToolbar(self.sim_canvas, self.sim_tab)
        self.sim_plot_layout.addWidget(self.sim_nav)
        self.sim_subplot = self.sim_fig.add_subplot(111)
        self.sim_subplot.grid(True, axis=&#34;y&#34;)
        self.show()
        # Absorption
        self.abs_fig = plt.figure()
        self.abs_canvas = FigureCanvas(self.abs_fig)
        self.abs_plot_layout.addWidget(self.abs_canvas)
        self.abs_nav = NavigationToolbar(self.abs_canvas, self.abs_tab)
        self.abs_plot_layout.addWidget(self.abs_nav)
        self.abs_subplot = self.abs_fig.add_subplot(111)
        self.abs_subplot.grid(True, axis=&#34;both&#34;)
        self.show()
        # Transmission
        self.tra_fig = plt.figure()
        # self.tra_fig, self.tra_ax = plt.subplots(nrows=1, ncols=1)
        self.tra_canvas = FigureCanvas(self.tra_fig)
        self.tra_plot_layout.addWidget(self.tra_canvas)
        self.tra_nav = NavigationToolbar(self.tra_canvas, self.transmission_tab)
        self.tra_plot_layout.addWidget(self.tra_nav)
        self.tra_subplot = self.tra_fig.add_subplot(111)
        self.tra_subplot.grid(True, axis=&#34;both&#34;)
        self.show()
        # Photocurrent
        self.pc_fig = plt.figure()
        self.pc_canvas = FigureCanvas(self.pc_fig)
        self.pc_plot_layout.addWidget(self.pc_canvas)
        self.pc_nav = NavigationToolbar(self.pc_canvas, self.photocurrent_tab)
        self.pc_plot_layout.addWidget(self.pc_nav)
        self.pc_subplot = self.pc_fig.add_subplot(111)
        self.pc_subplot.grid(True, axis=&#34;both&#34;)
        self.show()
        # Genetic algorithm
        self.ga_fig = plt.figure()
        self.ga_canvas = FigureCanvas(self.ga_fig)
        self.ga_plot_layout.addWidget(self.ga_canvas)
        self.ga_nav = NavigationToolbar(self.ga_canvas, self.ga_tab)
        self.ga_plot_layout.addWidget(self.ga_nav)
        self.ga_subplot = self.ga_fig.add_subplot(111)
        self.ga_subplot.grid(True, axis=&#34;both&#34;)
        self.show()

    # Structure and Wave Function
    def PlotStructure(self, sim=None):
        &#34;&#34;&#34;
        Function that interprets the structure data and create arrays to plot the graph.
        It is necessary to analyze the position and potential arrays in order to correctly plot the
        structure. In the interface between two materials the position is the same, but the energy
        is different. If the material is repeated, but the position is different, there is no need
        to create another point.
        &#34;&#34;&#34;
        # If this function is called without a specified sim, it gets the selected one from the
        # interface combobox
        if sim is None:
            try:  # Gets the current selected simulation
                sim = self.sim_list[self.simulation_cbox.currentIndex()]
            except:
                print(&#34;There is no simulation to choose from, create one first.&#34;)
                return

        self.ClearSimPlot()
        if len(sim.estrutura) &lt; 1:  # Only continue if there is a structure
            return
        # Creating the x and energy arrays  just for the plot
        sim.x_graf = np.array([0])
        sim.v_graf = np.array([sim.pot[0]])

        # Going through the layers and creating the arrays iteratively
        for i, en in enumerate(sim.pot):
            if (
                en == sim.v_graf[-1]
            ):  # If this layer has the same energy as the previous one
                sim.x_graf = np.append(sim.x_graf, [sim.x_graf[-1] + sim.estrutura[i]])
                sim.v_graf = np.append(sim.v_graf, [en])
            else:
                sim.x_graf = np.append(
                    sim.x_graf, [sim.x_graf[-1], sim.x_graf[-1] + sim.estrutura[i]]
                )
                sim.v_graf = np.append(sim.v_graf, [en, en])

        # Changing x and y to [nm] and [meV]
        sim.x_graf = 1.0e9 * sim.x_graf
        sim.v_graf = 1.0e3 * sim.v_graf

        # Centering the structure around 0
        # sim.x_graf = sim.x_graf - (np.max(sim.x_graf) - np.min(sim.x_graf)) / 2.0

        layers = len(sim.estrutura)
        central_layer = self.sim_central_layer_spb.value()
        &#34;&#34;&#34;
        This part of the code was used to put the 0 of the x-axis in the center of a 
        layer, but this doesn&#39;t work for Pedro&#39;s photocurrent calculations, therefore
        the 0 will be at the interfaces.
        # Creating the x-axis array - the x-axis 0 is centered in the target layer
        if central_layer &lt; 0:
            x0 = 0.0
        else:
            if (
                central_layer &gt; layers - 1
            ):  # In case the number of the layer exceeds the limit
                central_layer = layers - 1
            left_x_central = np.sum(
                sim.estrutura[0:central_layer]
            )  # Thickness of layers before
            central_thickness = sim.estrutura[
                central_layer
            ]  # Thickness of target layers
            x0 = -left_x_central - central_thickness / 2.0
        x0 = x0 / NM
        sim.x_graf = sim.x_graf + x0
        &#34;&#34;&#34;
        if central_layer &lt;= 0:
            x0 = 0.0
        else:
            # In case the number of the layer exceeds the limit
            if central_layer &gt; layers:
                central_layer = layers
            # Thickness of layers on the left side of the target interface
            x0 = -np.sum(sim.estrutura[0:central_layer])
        x0 = x0 / NM
        sim.x_graf = sim.x_graf + x0

        &#34;&#34;&#34;
        Plots the structure using arrays that were created by the UpdateStructure. Doesn&#39;t erase
        the graph, in order to allow comparison between two structures
        &#34;&#34;&#34;
        # sim = self.sim_list[self.simulation_cbox.currentIndex()]
        self.sim_subplot.plot(sim.x_graf, sim.v_graf)  # x in [nm] and y in [meV]
        self.sim_subplot.set_xlabel(&#34;Length (nm)&#34;)
        self.sim_subplot.set_ylabel(&#34;Energy (meV)&#34;)
        self.sim_subplot.set_xbound(sim.x_graf[0] - 0.2, sim.x_graf[-1] + 0.2)
        self.sim_subplot.set_ybound(np.min(sim.v_graf) - 50, np.max(sim.v_graf) + 100)
        self.sim_fig.tight_layout()
        self.sim_canvas.draw()

    def PlotSimResults(self, sim=None):
        &#34;&#34;&#34;
        Plost the results from ResultadoWF.
        &#34;&#34;&#34;
        # If this function is called without a specified sim, it gets the selected one from the
        # interface combobox
        if sim is None:
            try:  # Gets the current selected simulation
                sim = self.sim_list[self.simulation_cbox.currentIndex()]
            except:
                print(&#34;There is no simulation to choose from, create one first.&#34;)
                return

        # Gets the selected simulation
        # sim = self.sim_list[self.simulation_cbox.currentIndex()]
        self.sim_subplot.grid(True, axis=&#34;y&#34;)
        # Plots the probability density
        for result in sim.sim_ResultadoWF:
            self.sim_subplot.plot(result[0, :] / NM, result[3, :] * 1.0e3)
            # self.subplot_sim.plot(result[:, 0] / 1.0E9, result[:, 3] * 1.0E0)
        self.sim_canvas.draw()

    def ClearSimPlot(self):
        &#34;&#34;&#34;
        Clears the simulation plot.
        &#34;&#34;&#34;
        self.sim_fig.clf()
        self.sim_fig.tight_layout()
        self.sim_subplot = self.sim_fig.add_subplot(111)
        self.sim_canvas.draw()

    # Absorption
    def PlotAbsorption(self, sim=None):
        &#34;&#34;&#34;
        Plots the results from the absorption of the selected simulation.
        &#34;&#34;&#34;
        # If this function is called without a specified sim, it gets the selected one
        # from the interface combobox
        if sim is None:
            try:  # Gets the current selected simulation
                sim = self.sim_list[self.simulation_cbox.currentIndex()]
            except:
                print(&#34;There is no simulation to choose from, create one first.&#34;)
                return

        self.abs_subplot.plot(sim.abs_energy_axis, sim.abs_result)
        self.abs_subplot.set_xlabel(&#34;Energy (eV)&#34;)
        self.abs_subplot.set_ylabel(&#34;Absorption (u.a.)&#34;)
        self.abs_fig.tight_layout()
        self.abs_subplot.grid(True, axis=&#34;both&#34;)
        self.abs_canvas.draw()

    def ClearAbsPlot(self):
        &#34;&#34;&#34;
        Clears the absorption plot.
        &#34;&#34;&#34;
        self.abs_fig.clf()
        self.abs_fig.tight_layout()
        self.abs_subplot = self.abs_fig.add_subplot(111)
        self.abs_canvas.draw()

    # Transmission
    def PlotTransmission(self, sim=None):
        &#34;&#34;&#34;
        Plots the transmission. The transmission is only calculated after simulation was
        run.
        &#34;&#34;&#34;
        # If this function is called without a specified sim, it gets the selected one
        # from the interface combobox
        if sim is None:
            try:  # Gets the current selected simulation
                sim = self.sim_list[self.simulation_cbox.currentIndex()]
            except:
                print(&#34;There is no simulation to choose from, create one first.&#34;)
                return

        self.tra_subplot.plot(sim.sim_VecEnergy * 1.0e3, sim.sim_Transmission)
        self.tra_subplot.set_xlabel(&#34;Energy (eV)&#34;)
        self.tra_subplot.set_ylabel(&#34;Transmission (u.a.)&#34;)
        self.tra_fig.tight_layout()
        self.tra_subplot.grid(True, axis=&#34;both&#34;)
        # self.tra_subplot.set_yscale(&#34;log&#34;)
        self.tra_canvas.draw()

    def ClearTransPlot(self):
        &#34;&#34;&#34;
        Clears the Transmission plot.
        &#34;&#34;&#34;
        self.tra_fig.clf()
        self.tra_fig.tight_layout()
        self.tra_subplot = self.tra_fig.add_subplot(111)
        self.tra_canvas.draw()

    # Photocurrent
    def PlotPhotocurrent(self, sim=None):
        &#34;&#34;&#34;
        Plots the photocurrent. The photocurrent is only calculated after simulation was
        run.
        &#34;&#34;&#34;
        # If this function is called without a specified sim, it gets the selected one
        # from the interface combobox
        if sim is None:
            try:  # Gets the current selected simulation
                sim = self.sim_list[self.simulation_cbox.currentIndex()]
            except:
                print(&#34;There is no simulation to choose from, create one first.&#34;)
                return

        self.pc_subplot.plot(sim.sim_Photocurrent[0], sim.sim_Photocurrent[1])
        self.pc_subplot.set_xlabel(&#34;Energy (eV)&#34;)
        self.pc_subplot.set_ylabel(&#34;Photocurrent (u.a.)&#34;)
        self.pc_fig.tight_layout()
        self.pc_subplot.grid(True, axis=&#34;both&#34;)
        # self.pc_subplot.set_yscale(&#34;log&#34;)
        self.pc_canvas.draw()

    def ClearPhotocurrentPlot(self):
        &#34;&#34;&#34;
        Clears the photocurrent plot.
        &#34;&#34;&#34;
        self.pc_fig.clf()
        self.pc_fig.tight_layout()
        self.pc_subplot = self.pc_fig.add_subplot(111)
        self.pc_canvas.draw()

    # File inputs and outputs ##########################################################
    def ChooseOutputFolder(self):
        &#34;&#34;&#34;
        Prompts the user to choose the simulation data output folder. Inside this folder, there will
        be a folder with the simulation title.
        &#34;&#34;&#34;
        folder = QFileDialog.getExistingDirectory()
        if (
            folder
        ):  # If the output folder was properly selects, add the os separator to it
            os.path.join(folder, &#34;&#34;)  # OS independent separator
        self.output_folder_line.setText(folder)

        sim = self.sim_list[self.simulation_cbox.currentIndex()]
        sim.output_folder = self.output_folder_line.text()

    def SaveSimulation(self):
        &#34;&#34;&#34;
        Saves the structure, simulation and absorption parameters.
        &#34;&#34;&#34;
        sim = self.sim_list[self.simulation_cbox.currentIndex()]
        try:
            save_dir = os.path.join(sim.output_folder, f&#34;{sim.title}.qwsim&#34;)
            # print(f&#39;save_dir: {save_dir}&#39;)
            file, _ = QFileDialog.getSaveFileName(
                self,
                caption=&#34;Save structure and simulation parameters&#34;,
                directory=save_dir,
                filter=self.tr(&#34;*.qwsim&#34;),
            )

            output_file = open(file, &#34;wb&#34;)
            pickle.dump(sim, output_file)
            output_file.close()
        except:
            print(&#34;Couldn&#39;t save the structure&#34;)
            # If the user doesn&#39;t choose a filename, closing the interface, do nothing
            return

    def LoadSimulation(self):
        &#34;&#34;&#34;
        Loads structure and simulation data from a file
        &#34;&#34;&#34;
        try:  # Returns a tuple
            file, _ = QFileDialog.getOpenFileName(
                self, &#34;Loads the structure and simulation data&#34;, self.tr(&#34;*.qwsim&#34;)
            )
            input_file = open(file, &#34;rb&#34;)
            sim = pickle.load(input_file)

            self.sim_list.append(sim)
            self.simulation_cbox.setCurrentIndex(len(self.sim_list) - 1)
            self.UpdateStructureTable()
            self.UpdateSimList()
            self.UpdateLayerCount()
            # If an structure was saved, plot it
            try:  # The try-except is to avoid errors in case sim.structure doesn&#39;t exist
                if len(sim.estrutura) &gt; 0:
                    self.PlotStructure(sim)
            except:
                pass
            # If a simulation result was saved, plot it
            try:
                if sim.sim_ran:
                    self.PlotSimResults(sim)
            except:
                pass
            # If an absorption result was saved, plot it
            try:
                if sim.abs_ran:
                    self.PlotAbsorption(sim)
            except:
                pass
            self.UpdateInterface()

        except:
            # If an error happens upon opening the file, the function just returns False.
            print(&#34;Couldn&#39;t load the structure&#34;)
            return

    def CreateOutputFolder(self, sim):
        &#34;&#34;&#34;
        Checks whether the selected output folder exists or must be created
        &#34;&#34;&#34;
        # Defines the output folder based on the simulation title
        # output_folder = str(self.output_folder_line.text())
        output_folder = sim.output_folder
        # If the folder was not chosen, just get the file execution path
        if not output_folder:
            output_folder = os.path.dirname(os.path.abspath(__file__))
        # If the menu checkbox is checked (it is, by default) create a folder with the same name as
        # the simulation
        if self.adv_new_folder_chkbx.isChecked:
            output_folder = os.path.join(output_folder, sim.title)

        return output_folder

    def SaveSimOutput(self, sim):
        &#34;&#34;&#34;
        Based on the interface&#39;s checkboxes, saves the simulation output
        &#34;&#34;&#34;
        output_folder = self.CreateOutputFolder(sim)

        # To avoid repetition of the &#34;all checkbox&#34;
        save_all = self.sim_files_all_chkbx.isChecked()

        # After the end of the calculations, save the result in text files if desired
        if (
            save_all
            or self.sim_files_effm_chkbx.isChecked()
            or self.sim_files_energies_chkbx.isChecked()
            or self.sim_files_npe_chkbx.isChecked()
            or self.sim_files_pot_chkbx.isChecked()
            or self.sim_files_wf_chkbx.isChecked()
            or self.sim_files_x_chkbx.isChecked()
        ):
            data_folder = os.path.join(output_folder, &#34;Data&#34;)

            # if the folder to save the data doesn&#39;t exist, create it
            if not os.path.exists(data_folder):
                os.makedirs(data_folder)

        if save_all or self.sim_files_x_chkbx.isChecked():
            np.savetxt(os.path.join(data_folder, &#34;X Axis.txt&#34;), sim.sim_x, newline=&#34;\n&#34;)

        if save_all or self.sim_files_pot_chkbx.isChecked():
            np.savetxt(
                os.path.join(data_folder, &#34;Electrical Potential.txt&#34;),
                sim.sim_pot,
                newline=&#34;\n&#34;,
            )

        if save_all or self.sim_files_effm_chkbx.isChecked():
            np.savetxt(
                os.path.join(data_folder, &#34;Effective Mass.txt&#34;),
                sim.sim_effm_cte,
                newline=&#34;\n&#34;,
            )

        if save_all or self.sim_files_npe_chkbx.isChecked():
            np.savetxt(
                os.path.join(data_folder, &#34;Non-Parabolicity.txt&#34;),
                sim.sim_npe,
                newline=&#34;\n&#34;,
            )

        if save_all or self.sim_files_energies_chkbx.isChecked():
            np.savetxt(os.path.join(data_folder, &#34;Autoenergias.txt&#34;), sim.sim_Energias)

        if save_all or self.sim_files_wf_chkbx.isChecked():
            PastaWave = os.path.join(data_folder, &#34;Wave Functions&#34;)
            if not os.path.exists(PastaWave):
                os.makedirs(PastaWave)
            for a in range(len(sim.sim_Energias)):
                fname = f&#34;WF_E{a}_{sim.sim_Energias[a]:02.6f}.txt&#34;
                # The transposed is print, so that the WF is in a column, not row
                np.savetxt(os.path.join(PastaWave, fname), sim.sim_ResultadoWF[a].T)

    def SaveTransmissionOutput(self, sim):
        &#34;&#34;&#34;
        Based on the interface&#39;s checkboxes, saves the Transmission output
        &#34;&#34;&#34;
        output_folder = self.CreateOutputFolder(sim)

        # After the end of the calculations, save the result in text files if desired
        if (
            self.sim_files_all_chkbx.isChecked()
            or self.sim_files_trans_chkbx.isChecked()
        ):
            data_folder = os.path.join(output_folder, &#34;Data&#34;)

            # if the folder to save the data doesn&#39;t exist, create it
            if not os.path.exists(data_folder):
                os.makedirs(data_folder)

            output = np.column_stack((sim.sim_VecEnergy, sim.sim_Transmission))
            output_file = os.path.join(data_folder, &#34;Transmission Spectrum.txt&#34;)
            np.savetxt(output_file, output)

    def SavePhotocurrentOutput(self, sim):
        &#34;&#34;&#34;
        Based on the interface&#39;s checkboxes, saves the Transmission output
        &#34;&#34;&#34;
        output_folder = self.CreateOutputFolder(sim)

        # After the end of the calculations, save the result in text files if desired
        if self.sim_files_all_chkbx.isChecked() or self.sim_files_pc_chkbox.isChecked():
            data_folder = os.path.join(output_folder, &#34;Data&#34;)

            # if the folder to save the data doesn&#39;t exist, create it
            if not os.path.exists(data_folder):
                os.makedirs(data_folder)

            output = sim.sim_Photocurrent
            output_file = os.path.join(data_folder, &#34;Photocurrent Spectrum.txt&#34;)
            np.savetxt(output_file, output)

    def SaveGUIConfigFile(self):
        &#34;&#34;&#34;
        Saves all the values and settings on the interface to the &#34;interface.cfg&#34; file.
        This is meant to be a easy way of saving the default settings, so that the user doesn&#39;t need
        to change the values every time the software is opened, nor needs to manually edit the
        config file.
        The values must be in string format.
        &#34;&#34;&#34;
        # Reads the configuration defaults from the &#34;interface.cfg&#34; file:
        cfg = configparser.ConfigParser()
        file = os.path.join(self.base_path, &#34;interface.cfg&#34;)
        cfg.read(file)

        # Structure tab
        # Saves only the values of nm or ml, depending on the checkbox state
        if self.adv_nm_layers_chkbx.checkState():
            cfg[&#34;stru&#34;][&#34;barrier_nm&#34;] = f&#34;{self.barrier_nm_spb.value()}&#34;
            cfg[&#34;stru&#34;][&#34;well_nm&#34;] = f&#34;{self.well_nm_spb.value()}&#34;
        else:
            cfg[&#34;stru&#34;][&#34;barrier_ml&#34;] = f&#34;{self.barrier_ml_spb.value()}&#34;
            cfg[&#34;stru&#34;][&#34;well_ml&#34;] = f&#34;{self.well_ml_spb.value()}&#34;

        # Simulation tab
        cfg[&#34;simu&#34;][&#34;E0&#34;] = f&#34;{self.sim_E0_spb.value()}&#34;
        cfg[&#34;simu&#34;][&#34;dE&#34;] = f&#34;{self.sim_dE_spb.value()}&#34;
        cfg[&#34;simu&#34;][&#34;Ef&#34;] = f&#34;{self.sim_Ef_spb.value()}&#34;
        if self.adv_nm_layers_chkbx.checkState():
            cfg[&#34;simu&#34;][&#34;dx_nm&#34;] = f&#34;{self.sim_dx_nm_spb.value()}&#34;
        else:
            cfg[&#34;simu&#34;][&#34;dx_ml&#34;] = f&#34;{self.sim_dx_ml_spb.value()}&#34;
        cfg[&#34;simu&#34;][&#34;Efield&#34;] = f&#34;{self.sim_Efield_spb.value()}&#34;
        cfg[&#34;simu&#34;][&#34;central_layer&#34;] = f&#34;{self.sim_central_layer_spb.value()}&#34;
        # Checkboxes
        cfg[&#34;simu&#34;][&#34;output_all&#34;] = (
            &#34;True&#34; if self.sim_files_all_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;simu&#34;][&#34;output_effm&#34;] = (
            &#34;True&#34; if self.sim_files_effm_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;simu&#34;][&#34;output_energies&#34;] = (
            &#34;True&#34; if self.sim_files_energies_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;simu&#34;][&#34;output_npe&#34;] = (
            &#34;True&#34; if self.sim_files_npe_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;simu&#34;][&#34;output_pot&#34;] = (
            &#34;True&#34; if self.sim_files_pot_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;simu&#34;][&#34;output_trans&#34;] = (
            &#34;True&#34; if self.sim_files_trans_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;simu&#34;][&#34;output_wf&#34;] = (
            &#34;True&#34; if self.sim_files_wf_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;simu&#34;][&#34;output_x&#34;] = (
            &#34;True&#34; if self.sim_files_x_chkbx.checkState() else &#34;False&#34;
        )

        # Absorption tab
        cfg[&#34;abso&#34;][&#34;initial_WF&#34;] = f&#34;{self.abs_init_wf_spb.value()}&#34;
        cfg[&#34;abso&#34;][&#34;lorz_broad&#34;] = f&#34;{self.abs_broadening_spb.value()}&#34;
        cfg[&#34;abso&#34;][&#34;E0&#34;] = f&#34;{self.abs_E0_spb.value()}&#34;
        cfg[&#34;abso&#34;][&#34;dE&#34;] = f&#34;{self.abs_dE_spb.value()}&#34;
        cfg[&#34;abso&#34;][&#34;Ef&#34;] = f&#34;{self.abs_Ef_spb.value()}&#34;

        # Transmission tab

        # Photocurrent tab
        cfg[&#34;phot&#34;][&#34;E0&#34;] = f&#34;{self.pc_E0_spb.value()}&#34;
        cfg[&#34;phot&#34;][&#34;dE&#34;] = f&#34;{self.pc_dE_spb.value()}&#34;
        cfg[&#34;phot&#34;][&#34;Ef&#34;] = f&#34;{self.pc_Ef_spb.value()}&#34;

        # Genetic Algorithm tab
        cfg[&#34;gene&#34;][&#34;iterations&#34;] = f&#34;{self.ga_iter_spb.value():d}&#34;
        cfg[&#34;gene&#34;][&#34;population&#34;] = f&#34;{self.ga_pop_spb.value():d}&#34;
        cfg[&#34;gene&#34;][&#34;target_E&#34;] = f&#34;{self.ga_tgt_en_spb.value()}&#34;
        cfg[&#34;gene&#34;][&#34;target_E_margin&#34;] = f&#34;{self.ga_tgt_en_margin_spb.value()}&#34;
        cfg[&#34;gene&#34;][&#34;goal&#34;] = f&#34;{self.ga_goal_cbox.currentIndex():d}&#34;

        # Automation tab
        cfg[&#34;auto&#34;][&#34;target_layer&#34;] = f&#34;{self.auto_layer_spb.value():d}&#34;
        cfg[&#34;auto&#34;][&#34;thickness_initial&#34;] = f&#34;{self.auto_init_spb.value()}&#34;
        cfg[&#34;auto&#34;][&#34;thickness_step&#34;] = f&#34;{self.auto_step_spb.value()}&#34;
        cfg[&#34;auto&#34;][&#34;thickness_final&#34;] = f&#34;{self.auto_final_spb.value()}&#34;

        # Data tab

        # Advanced tab
        cfg[&#34;adva&#34;][&#34;create_new_folder&#34;] = (
            &#34;True&#34; if self.adv_new_folder_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;adva&#34;][&#34;use_nanometers&#34;] = (
            &#34;True&#34; if self.adv_nm_layers_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;adva&#34;][&#34;autorun_abs&#34;] = (
            &#34;True&#34; if self.adv_autorun_abs_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;adva&#34;][&#34;autorun_abs_initial_WF&#34;] = f&#34;{self.adv_wf0_spb.value()}&#34;
        cfg[&#34;adva&#34;][&#34;autorun_trans&#34;] = (
            &#34;True&#34; if self.adv_autorun_trans_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;adva&#34;][&#34;interface_to_split&#34;] = f&#34;{self.adv_split_layer_spb.value()}&#34;
        cfg[&#34;adva&#34;][&#34;method&#34;] = f&#34;{self.adv_method_cbox.currentIndex()}&#34;

        # Saves the configuration file
        with open(file, &#34;w&#34;) as configfile:
            cfg.write(configfile)

    # Run the calculations #############################################################
    # Absorption
    def RunAbsorption(self, sim=None):
        &#34;&#34;&#34;
        Calculates the structure&#39;s absorption spectra, the dipole moment, oscilator strenght and
        delta energy between the absorption peaks and the reference wavefunction (wf_0).
        &#34;&#34;&#34;
        # If this function is called without a specified sim, it gets the selected one from the
        # interface combobox
        if sim is None:
            try:  # Gets the current selected simulation
                sim = self.sim_list[self.simulation_cbox.currentIndex()]
            except:
                print(&#34;There is no simulation to choose from, create one first.&#34;)
                return
        # Checks whether there are at least two wavefunctions, in order to calculate the absorption.
        if len(sim.sim_Energias) &lt; 2:
            print(&#34;Cannot calculate absorption if there are less than 2 wavefunctions.&#34;)
            return
        # Collecting the relevant data from the GUI
        wf_0_index = int(self.abs_init_wf_spb.value())
        E0 = self.abs_E0_spb.value()
        Ef = self.abs_Ef_spb.value()
        dE = self.abs_dE_spb.value()
        # Linewidth broadening of the lorentzian. From &#34;Van Hove singularities in intersubband
        # transitions in multiquantum well photodetectors&#34; doi.org/10.1016/j.infrared.2006.10.016
        broadening = self.abs_broadening_spb.value()

        # Gets the choosen simulation
        # sim = self.sim_list[self.simulation_cbox.currentIndex()]
        sim.CalcAbs(wf_0_index, E0, Ef, dE, broadening)

        # Saving the absorption output to files
        output_folder = (
            sim.output_folder
        )  # As defined when the sim was created or &#34;change folder&#34;
        # Defines the output folder based on the simulation title
        if self.adv_new_folder_chkbx.isChecked:
            output_folder = os.path.join(output_folder, sim.title)
        # Saves in a folder called &#34;Absorption&#34;
        output_folder = os.path.join(output_folder, &#34;Absorption&#34;)
        if not os.path.exists(output_folder):
            os.makedirs(output_folder)

        try:
            data = np.column_stack(
                (sim.abs_delta_E, sim.abs_dipole, sim.abs_osc_strength)
            )
            filename = f&#34;DeltaE_DipoloEletrico_ForcadeOscilador_E{wf_0_index:01d}.txt&#34;
            np.savetxt(os.path.join(output_folder, filename), data)
        except:
            print(&#34;Could not save absorption results&#34;)

        try:
            data = np.column_stack((sim.abs_energy_axis, sim.abs_result))
            filename = f&#34;Absorcao_E{wf_0_index:01d}.txt&#34;
            np.savetxt(os.path.join(output_folder, filename), data)
        except:
            print(&#34;Could not save absorption results&#34;)

        # Plot the absorption and update the interface
        self.PlotAbsorption(sim)
        self.UpdateInterface()

    def RunAutomation(self):
        &#34;&#34;&#34;
        Creates an automation changing the thickness of the target layer by the values
        in the range defined by the user in the GUI
        &#34;&#34;&#34;
        # Gets the base simulation, which will be modified by the automated steps
        base_sim = self.sim_list[self.simulation_cbox.currentIndex()]

        # Obtaining the target range of thicknesses
        th_init = self.auto_init_spb.value()
        th_step = self.auto_step_spb.value()
        th_final = self.auto_final_spb.value()
        # List of thicknesses
        th_list = np.arange(th_init, th_final + th_step, th_step, dtype=float)

        # Defining whether the thickness is in nanometers or monolayers
        if (
            self.adv_nm_layers_chkbx.checkState()
        ):  # If user wants nanometers, use value as is
            th_unit = &#34;nm&#34;
        else:  # else, calculate dx as a multiple of monolayer = latpar/2
            # Correcting the units, if the value was entered in monolayers
            th_unit = &#34;ml&#34;
            th_list = th_list * base_sim.latpar / 2

        # Gets the index of the layer that must be modified
        tgt_layer = self.auto_layer_spb.value()
        # The target layer must exist. In case the structure doesn&#39;t have the defined layer, correct
        if tgt_layer &lt; 0:
            tgt_layer = 0
        elif tgt_layer &gt; len(base_sim.estrutura) - 1:
            tgt_layer = len(base_sim.estrutura) - 1

        slist = []
        # For each thickness
        for th in th_list:
            # Creates a copy of the original simulation
            new_sim = deepcopy(base_sim)
            # Puts it into the simulations list
            self.sim_list.append(new_sim)
            # Puts it into a list just for the multiprocessing
            slist.append(new_sim)
            # Changes the title based on the title of the base simulation and the modification
            new_sim.title = base_sim.title + f&#34; {th:.3f}{th_unit}&#34;
            # Changes the thickness of the target layer
            if new_sim.feature[tgt_layer] == &#34;Well&#34;:
                new_sim.ReplaceWell(th, tgt_layer)
            else:
                new_sim.ReplaceBarrier(th, tgt_layer)
            self.RunSimulation(new_sim)

        # cores = cpu_count()
        # p = Pool(processes=cores)
        # p = Pool(processes=1)
        # p.map(self.RunASim, slist)
        # with Pool(processes=cores) as p:
        #     for i, _ in enumerate(p.imap_unordered(self.RunASim, slist)):
        #         print(i)

        self.UpdateStructureTable()
        self.UpdateSimList()

    # Simulation
    def RunSimulation(self, sim=None):
        &#34;&#34;&#34;
        This function is a copy of &#34;Run&#34; but it takes the simulation as an argument
        instead of getting the selected simulation from the combobox.
        &#34;&#34;&#34;
        # If this function is called without a specified sim, it gets the selected one
        # from the interface combobox
        if sim is None:
            try:  # Gets the current selected simulation
                sim = self.sim_list[self.simulation_cbox.currentIndex()]
            except:
                print(&#34;There is no simulation to choose from, create one first.&#34;)
                return

        # Obtaining the target range of energies
        E0 = self.sim_E0_spb.value()
        Ef = self.sim_Ef_spb.value()
        dE = self.sim_dE_spb.value()

        # Reads the value of dx from the interface
        if self.adv_nm_layers_chkbx.checkState():
            # If user wants nanometers, use value as is
            dx = self.sim_dx_nm_spb.value()
            dx_unit = &#34;nm&#34;
        else:  # else, calculate dx as a multiple of monolayer = latpar/2
            dx = self.sim_dx_ml_spb.value()
            dx_unit = &#34;ml&#34;

        # From the interface, defines the interface of the wavefunction split
        split_i = self.adv_split_layer_spb.value()

        # From the structure tab, gets the index of the central layer
        central_layer = self.sim_central_layer_spb.value()

        # The method chosen by the user to perform the calculations
        # Methods avaliable:
        # 0 - &#34;Numerov - For&#34;
        # 1 - &#34;Numerov - Split&#34;
        # 2 - &#34;Numerov - Arrays&#34;
        # 3 - &#34;TMM&#34;
        # 4 - &#34;TMM - Split&#34;
        wf_method = self.adv_method_cbox.currentIndex()

        # Timing
        t_start_run = time.time()

        # Runs the calculations with information gathered from the interface and stored
        # at a &#34;sim&#34;.
        # Sim is the selected simulation, containing all relevant data
        sim.RunSim(wf_method, split_i, E0, Ef, dE, dx, dx_unit, central_layer)
        # Timing
        print(f&#34;Total time: {time.time() - t_start_run:.3f} s&#34;)

        self.SaveSimOutput(sim)
        self.PlotSimResults(sim)
        self.UpdateInterface()
        self.UpdateDataTable()
        # If the user wants, automatically calculate the absorption, transmission or
        # photocurrent after the main simulation
        if self.sim_autorun_abs_chkbx.checkState():
            self.RunAbsorption(sim)
        if self.sim_autorun_tra_chkbx.checkState():
            self.RunTransmission(sim)
        if self.sim_autorun_pc_chkbx.checkState():
            self.RunPhotocurrent(sim)

    # Transmission
    def RunTransmission(self, sim=None):
        &#34;&#34;&#34;
        Performs the calculation of the transmission and displays it on the graph.
        &#34;&#34;&#34;
        # If this function is called without a specified sim, it gets the selected one
        # from the interface combobox
        if sim is None:
            try:  # Gets the current selected simulation
                sim = self.sim_list[self.simulation_cbox.currentIndex()]
            except:
                print(&#34;There is no simulation to choose from, create one first.&#34;)
                return

        sim.Transmission()

        self.PlotTransmission(sim)
        self.SaveTransmissionOutput(sim)

    def RunPhotocurrent(self, sim=None):
        &#34;&#34;&#34;
        Performs the calculation of the Photocurrent and plots on the graph.
        &#34;&#34;&#34;
        # If this function is called without a specified sim, it gets the selected one
        # from the interface combobox
        if sim is None:
            try:  # Gets the current selected simulation
                sim = self.sim_list[self.simulation_cbox.currentIndex()]
            except:
                print(&#34;There is no simulation to choose from, create one first.&#34;)
                return

        # Reads the value of dx from the interface
        if self.adv_nm_layers_chkbx.checkState():
            # If user wants nanometers, use value as is
            dx = self.sim_dx_nm_spb.value()
            dx_unit = &#34;nm&#34;
        else:  # else, calculate dx as a multiple of monolayer = latpar/2
            dx = self.sim_dx_ml_spb.value()
            dx_unit = &#34;ml&#34;

        # Obtaining the target range of energies and converting to eV
        E0 = self.pc_E0_spb.value() * 1.0e-3
        Ef = self.pc_Ef_spb.value() * 1.0e-3
        dE = self.pc_dE_spb.value() * 1.0e-3

        sim.RunPhotocurrent(dx, E0, Ef, dE)

        self.PlotPhotocurrent(sim)
        self.SavePhotocurrentOutput(sim)

    # Simulation instance functions
    def CreateSimulation(self, title, materials):
        &#34;&#34;&#34;
        Function that creates a new simulation with the relevant information
        &#34;&#34;&#34;
        # Creating the arrays necessary to the simulation
        array_data = dict()
        array_data[&#34;estrutura&#34;] = np.array([], dtype=np.float64)
        array_data[&#34;massa_eff_const&#34;] = np.array([], dtype=np.float64)
        array_data[&#34;pot&#34;] = np.array([], dtype=np.float64)
        array_data[&#34;E_nonparab&#34;] = np.array([], dtype=np.float64)
        # Loads the available materias from the file
        self.mat = configparser.ConfigParser()
        self.mat.read(os.path.join(self.base_path, &#34;materials.data&#34;))
        # Defining material properties from the materials.data file
        material_data = dict()
        material_data[&#34;latpar&#34;] = self.mat[materials].getfloat(&#34;latpar&#34;)
        material_data[&#34;barrier&#34;] = self.mat[materials][&#34;barrier&#34;]
        material_data[&#34;m_eff_ct_barrier&#34;] = self.mat[materials].getfloat(
            &#34;m_eff_ct_barrier&#34;
        )
        material_data[&#34;e_nonparab_barrier&#34;] = self.mat[materials].getfloat(
            &#34;e_nonparab_barrier&#34;
        )
        material_data[&#34;pot_barrier&#34;] = self.mat[materials].getfloat(&#34;pot_barrier&#34;)
        material_data[&#34;well&#34;] = self.mat[materials][&#34;well&#34;]
        material_data[&#34;m_eff_ct_well&#34;] = self.mat[materials].getfloat(&#34;m_eff_ct_well&#34;)
        material_data[&#34;pot_well&#34;] = self.mat[materials].getfloat(&#34;pot_well&#34;)
        material_data[&#34;e_nonparab_well&#34;] = self.mat[materials].getfloat(
            &#34;e_nonparab_well&#34;
        )

        # Creates the simulation and puts it into a list of simulations
        self.sim_list.append(simdata.SimData(title, array_data, material_data))
        self.current_number += 1
        self.new_sim_window.close()
        self.CreatedNewSimulation()

    def DeleteSimulation(self):
        &#34;&#34;&#34;
        Deletes the simulation selected in the combobox.
        &#34;&#34;&#34;
        # Gets the index of the selected simulation
        current_index = self.simulation_cbox.currentIndex()
        list_len = len(self.sim_list)

        # Removes it from the simulations list, if not empty
        if list_len == 0:
            return
        self.sim_list.pop(current_index)

        # if it was the last item in the combobox, select the previous
        if current_index == list_len - 1:
            self.simulation_cbox.setCurrentIndex(current_index - 1)
        # else if just selects the next item
        else:
            self.simulation_cbox.setCurrentIndex(current_index)

        # Calls the function that updates the interface with the simulation selected from the
        # combobox
        # Updates the combobox to reflect the change made to the simulation list
        self.UpdateInterface()
        self.UpdateSimList()
        self.UpdateLayerCount()
        # self.ChangedSimulation()

    def RenameSimulation(self):
        # Gets the current selected simulation
        try:
            sim = self.sim_list[self.simulation_cbox.currentIndex()]
        except:
            print(&#34;There is no simulation to choose from, create one first.&#34;)
            return
        # Creates a new window pasing the selected simulation
        self.rename_window = RenameSimWindow(sim)
        # Shows the window
        self.rename_window.show()
        # Connects the signal to the function used to close the window
        self.rename_window.signal_renamed.connect(self.CloseRenameWindow)

    def CopySimulation(self):
        &#34;&#34;&#34;
        Copies the current simulation creating a new instance with the same attributes and opens the
        title window so that the user can change the title.
        &#34;&#34;&#34;
        # Gets the current selected simulation
        try:
            current_sim = self.sim_list[self.simulation_cbox.currentIndex()]
        except:
            print(&#34;There is no simulation to choose from, create one first.&#34;)
            return

        # Copies the current simulation and adds it to the list
        new_sim = deepcopy(current_sim)
        self.sim_list.append(new_sim)

        # Creates a new window
        self.rename_window = RenameSimWindow(new_sim)
        # Shows the window
        self.rename_window.show()
        # Connects the signal to the function used to close the window
        # This window will be closed by another function, which is called when the user
        # confirms the name of the new simulation. This is done by a signal emitted from
        # the TitleWindow.
        self.rename_window.signal_renamed.connect(self.CloseRenameWindow)

    # Functions related to other windows ###############################################
    def CloseRenameWindow(self):
        &#34;&#34;&#34;
        Closes the window that was opened to change the simulation name.
        &#34;&#34;&#34;
        self.UpdateSimList()
        self.rename_window.close()

    def OpenNewSimWindow(self):
        &#34;&#34;&#34;
        Creates and opens the window that will create the title for the new simulation.
        &#34;&#34;&#34;
        self.new_sim_window = NewSimWindow(self.current_number)
        # Shows the window
        self.new_sim_window.show()
        # Connects the signal to the function used to close the window
        self.new_sim_window.signal_updated_current_number.connect(
            self.UpdateCurrentNumber
        )
        # This window will be closed by another function, which is called when the user
        # confirms the name of the new simulation. This is done by a signal emitted from
        # the TitleWindow.
        self.new_sim_window.signal_new_title.connect(self.CreateSimulation)

    def UpdateCurrentNumber(self, cnum):
        &#34;&#34;&#34;
        Updates the current number, in order to keep track of how many simulations were run.
        &#34;&#34;&#34;
        self.current_number = int(cnum)

    def Sobre(self):
        &#34;&#34;&#34;
        Opens the &#34;About&#34; window
        &#34;&#34;&#34;
        # chamando a nova classe SobreWindow que cria uma nova janela
        # se nao colocar o self, garbage collection will remove that object as soon as setupUi
        # method finishes.
        self.Sobre = SobreWindow()
        # mostrando na tela a classe criada para a segunda janela
        self.Sobre.show()

    # Legacy functions #################################################################
    def Campo(self):
        &#34;&#34;&#34;
        Função que aplica o campo elétrico à estrutura no momento que o usuário aperta o botão
        apply.
        &#34;&#34;&#34;
        l = self.sim.self.sim.x_graf
        # trazendo o grafico para o centro da estrutura e colocando em nm
        l = l - l[-1] / 2  # / 1E-9
        self.sim.v_graf = (
            self.sim.v_graf - self.sim_Efield_spb.value() * 1.0e-4 * l
        )  # 1E5 * NM
        self.sim.e_field = self.sim.e_field + self.sim_Efield_spb.value()
        self.label_campo.setText(str(self.sim.e_field) + &#34; kV/cm&#34;)
        # So altero o vetor posicao ao clicar a primeira vez (quando x0 = 0). Depois disso, o x ja
        # esta definido
        if self.sim.x0 == 0:
            self.sim.x0 = self.sim.x0 - np.sum(self.sim.estrutura) / 2
            # este valor vai ser usado no calculo quando usarmos a funcao run.

        v = self.sim.v_graf
        self.sim.self.sim.x_graf = l

        self.UpdateSimGraph()


class SobreWindow(QMainWindow):
    &#34;&#34;&#34;
    About window
    &#34;&#34;&#34;

    def __init__(self, parent=None):
        super(SobreWindow, self).__init__(parent)
        # uic.loadUi(os.path.join(os.getcwd(), &#34;GUI&#34;, &#34;Sobre_Gui.ui&#34;), self)
        uic.loadUi(os.path.join(os.path.dirname(__file__), &#34;GUI&#34;, &#34;Sobre_Gui.ui&#34;), self)
        self.webpage_btn.clicked.connect(self.webpage)
        self.Ok_btn.clicked.connect(self.close)

    def webpage(self):
        webbrowser.open(&#34;http://www.if.ufrj.br/~gpenello/&#34;)


class NewSimWindow(QWidget):
    &#34;&#34;&#34;
    Window that allows the user to create a new simulation.
    &#34;&#34;&#34;

    signal_new_title = pyqtSignal(str, str)
    signal_updated_current_number = pyqtSignal(int)

    def __init__(self, current_number, parent=None):
        super(NewSimWindow, self).__init__(parent)
        uic.loadUi(
            os.path.join(os.path.dirname(__file__), &#34;GUI&#34;, &#34;New_Simulation.ui&#34;), self
        )

        self.ConnectSignals()
        # Load the information from the configuration file to the UI and updates other values
        self.InterfaceSetup(current_number)
        # Creates a timer to update the texts
        self.CreateInterfaceTimer()

    def InterfaceSetup(self, current_number):
        &#34;&#34;&#34;
        Fills the interface with the updated values.
        &#34;&#34;&#34;
        # Set the options in the comboboxes
        options = [&#34;No&#34;, &#34;Before Title&#34;, &#34;After Title&#34;]
        for option in options:
            self.title_number_cbox.addItem(option)
            self.title_date_cbox.addItem(option)
            self.title_time_cbox.addItem(option)
            self.title_materials_cbox.addItem(option)

        # Loads the available materias from the file
        self.mat = configparser.ConfigParser()
        self.mat.read(
            os.path.join(os.path.dirname(os.path.realpath(__file__)), &#34;materials.data&#34;)
        )

        for pair in self.mat.sections():
            self.materials_cbox.addItem(pair)

        # Updates the current simulation number
        self.number_spb.setValue(current_number)

    def ConnectSignals(self):
        &#34;&#34;&#34;
        Definition of the interaction between button clicks, signals and actions.
        &#34;&#34;&#34;
        # Set the focus to the title line, so that the user can type right away
        self.title_line.setFocus()

        # The window might be closed in three ways:
        # pressing enter while the title_line is selected
        self.title_line.returnPressed.connect(self.SetTitle)
        # or pressing enter while it&#39;s selected
        self.create_simulation_btn.setDefault(True)
        # or by clicking the create_simulation button
        self.create_simulation_btn.clicked.connect(self.SetTitle)

        # When the user changes the simulation number, the main window gets a signal
        # If the value in the number spinbox was modified, update the self.current_number
        self.number_spb.valueChanged.connect(self.UpdatedCurrentNumber)

    def UpdatedCurrentNumber(self):
        self.current_number = self.number_spb.value()
        self.signal_updated_current_number.emit(self.number_spb.value())

    def CreateInterfaceTimer(self):
        &#34;&#34;&#34;
        Creates a QTimer that regularly updates the interface, in order to keep track of the current
        time.
        &#34;&#34;&#34;
        self.UpdateTexts()  # Runs the function that updates the title once just to keep the ui tidy
        self.txt_timer = QTimer()
        txt_update_interval = 200  # ms
        self.txt_timer.start(txt_update_interval)
        self.txt_timer.timeout.connect(self.UpdateTexts)

    def SetTitle(self):
        &#34;&#34;&#34;
        When the user clicks the button or press Enter, this function will get the title, the
        current selection of materials and emit a signal with this information, so that the main
        window can create a new simulation.
        &#34;&#34;&#34;
        title = self.ComposeTitle()
        materials = self.materials_cbox.currentText()
        self.signal_new_title.emit(title, materials)

    def UpdateTexts(self):
        &#34;&#34;&#34;
        Keeps the info shown on the interface updated
        &#34;&#34;&#34;
        self.number_spb.setValue(self.current_number)
        now = time.localtime()
        self.date_text.setText(time.strftime(&#34;%Y-%m-%d&#34;, now))
        self.time_text.setText(time.strftime(&#34;%Hh%Mm%Ss&#34;, now))
        self.materials_text.setText(self.materials_cbox.currentText())
        self.name_preview_text.setText(self.ComposeTitle())

    def ComposeTitle(self):
        &#34;&#34;&#34;
        Function that reads the options defined on the interface and returns the title based on that
        The items are inserted in the order the comboboxes appear:
        Number Date Time Material Title Number Date Time Material
        &#34;&#34;&#34;
        title = self.title_line.text()
        now = time.localtime()

        if self.title_materials_cbox.currentIndex() == 1:
            title = self.materials_cbox.currentText() + &#34; &#34; + title
        if self.title_time_cbox.currentIndex() == 1:
            title = time.strftime(&#34;%Hh%Mm%Ss&#34;, now) + &#34; &#34; + title
        if self.title_date_cbox.currentIndex() == 1:
            title = time.strftime(&#34;%Y-%m-%d&#34;, now) + &#34; &#34; + title
        if self.title_number_cbox.currentIndex() == 1:
            title = str(self.number_spb.value()) + &#34; &#34; + title

        # Just in case there are trailing spaces due to the title being empty
        title = title.rstrip()

        if self.title_materials_cbox.currentIndex() == 2:
            title += &#34; &#34; + self.materials_cbox.currentText()
        if self.title_time_cbox.currentIndex() == 2:
            title += &#34; &#34; + time.strftime(&#34;%Hh%Mm%Ss&#34;, now)
        if self.title_date_cbox.currentIndex() == 2:
            title += &#34; &#34; + time.strftime(&#34;%Y-%m-%d&#34;, now)
        if self.title_number_cbox.currentIndex() == 2:
            title += &#34; &#34; + str(self.number_spb.value())

        # Just in case there are leading spaces due to the title being empty
        title = title.lstrip()

        return title


class RenameSimWindow(QWidget):
    &#34;&#34;&#34;
    Window that is shown when the user renames or copies a simulation
    &#34;&#34;&#34;

    signal_renamed = pyqtSignal()

    def __init__(self, sim, parent=None):
        super(RenameSimWindow, self).__init__(parent)
        # uic.loadUi(os.path.join(os.getcwd(), &#34;GUI&#34;, &#34;Sobre_Gui.ui&#34;), self)
        uic.loadUi(
            os.path.join(os.path.dirname(__file__), &#34;GUI&#34;, &#34;RenameSimulation.ui&#34;), self
        )
        self.rename_btn.clicked.connect(lambda: self.Rename(sim))
        # Set the focus to the title line, so that the user can type right away
        self.title_line.setFocus()
        # The window might be closed in three ways:
        # pressing enter while the title_line is selected
        self.title_line.returnPressed.connect(lambda: self.Rename(sim))
        # or pressing enter while it&#39;s selected
        self.rename_btn.setDefault(True)
        # or by clicking the create_simulation button
        self.rename_btn.clicked.connect(lambda: self.Rename(sim))

        self.title_line.setText(sim.title)

    def Rename(self, sim):
        &#34;&#34;&#34;
        Function called when the user clicks on the &#34;rename&#34; button. Renames the title of sim.
        &#34;&#34;&#34;
        # Gets the string from the text box
        title = self.title_line.text()
        # Just in case there are leading spaces due to the title being empty
        sim.title = title.lstrip()
        self.signal_renamed.emit()


if __name__ == &#34;__main__&#34;:
    # Create the GUI application
    app = QApplication(sys.argv)

    # Creating splash screen
    splash_pix = QPixmap(os.path.join(&#34;Imagens&#34;, &#34;SplashScreen5.png&#34;))
    splash = QSplashScreen(splash_pix, Qt.WindowStaysOnTopHint)
    splash.setMask(splash_pix.mask())
    splash.show()
    time.sleep(0.2)
    splash.close()
    # app.processEvents()

    # instantiate the main window
    mw = MainWindow()
    # show it
    mw.show()
    # Revert changes to matplotlib rc params
    plt.rcParams.update(plt.rcParamsDefault)
    # start the Qt main loop execution, exiting from this script
    # with the same return code of Qt application
    sys.exit(app.exec_())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="e-mulate.MainWindow"><code class="flex name class">
<span>class <span class="ident">MainWindow</span></span>
<span>(</span><span>parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Main window</p>
<p>Initialization of the main window</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MainWindow(QMainWindow):
    &#34;&#34;&#34;
    Main window
    &#34;&#34;&#34;

    def __init__(self, parent=None):
        &#34;&#34;&#34;
        Initialization of the main window
        &#34;&#34;&#34;
        super(MainWindow, self).__init__(parent)
        # Loads the ui
        self.base_path = os.path.dirname(os.path.realpath(__file__))
        uic.loadUi(
            os.path.join(self.base_path, &#34;GUI&#34;, &#34;TM_tabs.ui&#34;),
            self,
        )
        # Sets the window icon
        self.setWindowIcon(
            QIcon(
                os.path.join(
                    self.base_path,
                    &#34;Imagens&#34;,
                    &#34;favicon.ico&#34;,
                )
            )
        )

        # Reads the configuration file and create the corresponding variables
        self.mat = configparser.ConfigParser()
        self.mat.read(os.path.join(self.base_path, &#34;materials.data&#34;))

        # Creating the list containing all simulations
        self.sim_list = []
        # Stores the number of the current simulation
        self.current_number = 1

        self.ConnectSignals()
        # Calls an auxiliary script that contains interface configuration functions
        interface_config.run(self)
        self.CreatePlots()
        self.InitializeStructTable()
        self.InitializeDataTable()
        self.UpdateInterface()

    # GUI ##############################################################################
    def ConnectSignals(self):
        &#34;&#34;&#34;
        Connect the signals from buttons to functions.
        Disables any button that should only be enabled after a new simulation is
        created.
        &#34;&#34;&#34;
        # Lower bar
        # self.new_btn.clicked.connect(self.new_sim_window.show)
        self.new_btn.clicked.connect(self.OpenNewSimWindow)
        self.save_btn.clicked.connect(self.SaveSimulation)
        self.load_btn.clicked.connect(self.LoadSimulation)
        self.delete_btn.clicked.connect(self.DeleteSimulation)
        self.output_folder_btn.clicked.connect(self.ChooseOutputFolder)
        self.simulation_cbox.currentIndexChanged.connect(self.UpdateInterface)
        self.rename_btn.clicked.connect(self.RenameSimulation)
        self.copy_btn.clicked.connect(self.CopySimulation)

        # Design tab
        self.add_well_btn.clicked.connect(lambda: self.UpdateStructure(&#34;AddWell&#34;))
        self.add_barrier_btn.clicked.connect(lambda: self.UpdateStructure(&#34;AddBarrier&#34;))
        self.replace_well_btn.clicked.connect(
            lambda: self.UpdateStructure(&#34;ReplaceWell&#34;)
        )
        self.replace_barrier_btn.clicked.connect(
            lambda: self.UpdateStructure(&#34;ReplaceBarrier&#34;)
        )
        self.insert_well_btn.clicked.connect(lambda: self.UpdateStructure(&#34;InsertWell&#34;))
        self.insert_barrier_btn.clicked.connect(
            lambda: self.UpdateStructure(&#34;InsertBarrier&#34;)
        )
        self.remove_selected_btn.clicked.connect(
            lambda: self.UpdateStructure(&#34;RemoveSelected&#34;)
        )
        self.remove_last_btn.clicked.connect(lambda: self.UpdateStructure(&#34;RemoveLast&#34;))
        self.remove_all_btn.clicked.connect(lambda: self.UpdateStructure(&#34;RemoveAll&#34;))
        self.well_ml_spb.valueChanged.connect(self.UpdateUnits)
        self.well_nm_spb.valueChanged.connect(self.UpdateUnits)
        self.barrier_ml_spb.valueChanged.connect(self.UpdateUnits)
        self.barrier_nm_spb.valueChanged.connect(self.UpdateUnits)

        # Simulation tab
        self.sim_Efield_btn.clicked.connect(self.Campo)
        # Electric field button and spinbox are disabled because they don&#39;t work
        self.sim_Efield_btn.setEnabled(False)
        self.sim_Efield_spb.setEnabled(False)
        self.sim_run_btn.clicked.connect(lambda: self.RunSimulation())
        self.sim_plot_results_btn.clicked.connect(lambda: self.PlotSimResults())
        self.sim_plot_structure_btn.clicked.connect(lambda: self.PlotStructure())
        self.sim_clear_plot_btn.clicked.connect(self.ClearSimPlot)
        self.sim_dx_ml_spb.valueChanged.connect(self.UpdateUnits)
        self.sim_dx_nm_spb.valueChanged.connect(self.UpdateUnits)
        self.sim_central_layer_spb.valueChanged.connect(lambda: self.PlotStructure())

        # Absorption tab
        self.abs_run_btn.clicked.connect(lambda: self.RunAbsorption())
        self.abs_plot_btn.clicked.connect(lambda: self.PlotAbsorption())
        self.abs_clear_plot_btn.clicked.connect(self.ClearAbsPlot)

        # Transmission tab
        self.tra_run_btn.clicked.connect(lambda: self.RunTransmission())
        self.tra_plot_btn.clicked.connect(lambda: self.PlotTransmission())
        self.tra_clear_plot_btn.clicked.connect(lambda: self.ClearTransPlot())

        # Photocurrent tab
        self.pc_run_btn.clicked.connect(lambda: self.RunPhotocurrent())
        self.pc_clear_plot_btn.clicked.connect(lambda: self.ClearPhotocurrentPlot())

        # GA tab
        # self.ga_btn.clicked.connect(self.Sobre)

        # Automation tab
        self.auto_run_btn.clicked.connect(self.RunAutomation)

        # Advanced options tab
        self.adv_nm_layers_chkbx.stateChanged.connect(self.UpdateUnits)
        self.adv_save_gui_config.clicked.connect(self.SaveGUIConfigFile)

        # Actions from menus
        # File Menu
        # self.action_new.triggered.connect(self.NewSimulation)
        self.action_new.triggered.connect(self.OpenNewSimWindow)
        self.action_load.triggered.connect(self.LoadSimulation)
        self.action_save.triggered.connect(self.SaveSimulation)
        self.action_exit.triggered.connect(exit)
        # Help Menu
        self.action_about.triggered.connect(self.Sobre)

    def UpdateUnits(self):
        &#34;&#34;&#34;
        This function is used to update the layer thickness spinboxes, making sure that
        the value in nm corresponds an integer multiple of the lattice parameter,
        defined by the monolayer&#39;s spinboxes, and vice versa.
        This routine is divided in two parts (by the try-except), things that can be
        determined before creating a simulation and the ones that depend on the lattice
        parameter.
        &#34;&#34;&#34;
        # If the user prefers to use nanometers instead of monolayers:
        if self.adv_nm_layers_chkbx.checkState():
            # Changes the suffix of the spinboxes
            self.auto_step_spb.setSuffix(&#34; nm&#34;)
            self.auto_final_spb.setSuffix(&#34; nm&#34;)
            self.auto_init_spb.setSuffix(&#34; nm&#34;)
        else:  # If the user is using monolayers
            # Changes the suffix of the spinboxes
            self.auto_step_spb.setSuffix(&#34; ML&#34;)
            self.auto_final_spb.setSuffix(&#34; ML&#34;)
            self.auto_init_spb.setSuffix(&#34; ML&#34;)

        # The lattice parameter is only defined after a simulation was created.
        try:  # Gets the current simulation and the value of the lattice parameter
            sim = self.sim_list[self.simulation_cbox.currentIndex()]
            ml = sim.latpar / 2.0
        except:
            return

        # Identifies which spinbox was modified (the one which called this function)
        op = self.sender()

        # If the user prefers to use nanometers instead of monolayers:
        if self.adv_nm_layers_chkbx.checkState():
            # Disable the ml spinboxes, so that the user cannot interact with them
            self.barrier_ml_spb.setEnabled(False)
            self.well_ml_spb.setEnabled(False)
            self.sim_dx_ml_spb.setEnabled(False)
            # Enable the nm spinboxes
            self.barrier_nm_spb.setEnabled(True)
            self.well_nm_spb.setEnabled(True)
            self.sim_dx_nm_spb.setEnabled(True)

            # Set the value of the monolayers spinboxes, base on the nm values (converted to meters)
            # if op == self.barrier_nm_spb:
            self.barrier_ml_spb.setValue(
                np.round(self.barrier_nm_spb.value() * NM / ml, 3)
            )
            # if op == self.well_nm_spb:
            self.well_ml_spb.setValue(np.round(self.well_nm_spb.value() * NM / ml, 3))
            self.sim_dx_ml_spb.setValue(
                np.round(self.sim_dx_nm_spb.value() * NM / ml, 3)
            )

        # If the user is using monolayers
        else:
            # Enable the ml spinboxes, so that the user can interact with them
            self.barrier_ml_spb.setEnabled(True)
            self.well_ml_spb.setEnabled(True)
            self.sim_dx_ml_spb.setEnabled(True)
            # Disable the nm spinboxes
            self.barrier_nm_spb.setEnabled(False)
            self.well_nm_spb.setEnabled(False)
            self.sim_dx_nm_spb.setEnabled(False)
            # if op == self.barrier_ml_spb:
            # lp is in meters, converts to nm
            self.barrier_nm_spb.setValue(self.barrier_ml_spb.value() * ml / NM)
            # if op == self.well_ml_spb:
            self.well_nm_spb.setValue(self.well_ml_spb.value() * ml / NM)
            self.sim_dx_nm_spb.setValue(self.sim_dx_ml_spb.value() * ml / NM)

    def CreatedNewSimulation(self):
        &#34;&#34;&#34;
        Called after a new simulation is created, just to update the interface
        &#34;&#34;&#34;
        self.simulation_cbox.setCurrentIndex(len(self.sim_list) - 1)
        # Defines the output folder based on the simulation title
        sim = self.sim_list[
            -1
        ]  # The new simulation was just appended to the end of the list
        sim.output_folder = str(self.output_folder_line.text())
        self.PlotStructure()
        self.UpdateStructureTable()
        self.UpdateSimList()
        self.UpdateInterface()
        self.UpdateLayerCount()
        self.UpdateUnits()

    def UpdateSimList(self):
        &#34;&#34;&#34;
        If simulations are added, deleted or loaded, needs to update the list
        &#34;&#34;&#34;
        # Clears the simulation list
        self.simulation_cbox.clear()
        # Fills the simulation combobox with every simulation from the list
        for sim in self.sim_list:
            self.simulation_cbox.addItem(sim.title)
        self.simulation_cbox.setCurrentIndex(len(self.sim_list) - 1)

    def UpdateStructure(self, op):
        &#34;&#34;&#34;
        Function that adds, inserts or removes layers from the surface, based on the user choice on
        the GUI.
        op is the operation the user wants to perform, defined in self.ConnectSignals
        &#34;&#34;&#34;
        sim = self.sim_list[self.simulation_cbox.currentIndex()]

        # Adding a new well
        if op == &#34;AddWell&#34;:
            sim.AddWell(self.well_nm_spb.value())

        # Adding a new barrier
        elif op == &#34;AddBarrier&#34;:
            sim.AddBarrier(self.barrier_nm_spb.value())

        # Replacing a well
        elif op == &#34;ReplaceWell&#34;:
            index = self.struct_table.currentRow()  # Selected table line
            if index == -1:  # In case there is nothing to replace
                return
            sim.ReplaceWell(self.well_nm_spb.value(), index)

        # Replacing a barrier
        elif op == &#34;ReplaceBarrier&#34;:
            index = self.struct_table.currentRow()  # Selected table line
            if index == -1:  # In case there is nothing to replace
                return
            sim.ReplaceBarrier(self.barrier_nm_spb.value(), index)

        # Inserting a well
        elif op == &#34;InsertWell&#34;:
            index = self.struct_table.currentRow()  # Selected table line
            sim.InsertWell(self.well_nm_spb.value(), index)

        # Inserting a barrier
        elif op == &#34;InsertBarrier&#34;:
            index = self.struct_table.currentRow()  # Selected table line
            sim.InsertBarrier(self.barrier_nm_spb.value(), index)

        elif op == &#34;RemoveSelected&#34;:
            index = self.struct_table.currentRow()  # Linha da tabela selecionada
            if len(sim.estrutura) &gt; 1:  # If there is a structure, delete the last item
                sim.RemoveSelected(index)
            else:
                op = &#34;RemoveAll&#34;  # Just to avoid repeating 5 lines of code

        elif op == &#34;RemoveLast&#34;:
            if len(sim.estrutura) &gt; 1:  # If there is a structure, delete the last item
                sim.RemoveSelected(-1)
            else:
                op = &#34;RemoveAll&#34;  # Just to avoid repeating 5 lines of code

        # This is not &#34;elif&#34; just so that the &#34;else&#34; from RemoveSelected and RemoveLast work
        if op == &#34;RemoveAll&#34;:
            sim.RemoveAll()

        # Since the structure was modified, define this simulation as not ran
        sim.sim_ran = False
        sim.abs_ran = False

        # Updates table, graph and buttons
        self.UpdateStructureTable()
        self.PlotStructure(sim)
        self.UpdateInterface()
        self.UpdateLayerCount()

    def UpdateLayerCount(self):
        &#34;&#34;&#34;
        Calculates the number of layers and updates the Spinbox on the advanced tab
        &#34;&#34;&#34;

        try:  # If there is a simulation and this simulation has at least one layer
            sim = self.sim_list[self.simulation_cbox.currentIndex()]
            layers = len(sim.estrutura)
            self.adv_total_layers_spb.setValue(layers)
        except:  # If there is no simulation or it doesn&#39;t have any layers yet
            self.adv_total_layers_spb.setValue(0)

    def UpdateInterface(self):
        &#34;&#34;&#34;
        Updates the buttons, list of simulations available on the simulations combobox.
        This simulation is called almost everytime after user interaction.
        &#34;&#34;&#34;
        # Check whether there are simulations
        # The selected simulation defines whether some options on the interface are available
        # If there are no simulations, disable most buttons, except &#34;load&#34; and &#34;new&#34;
        if len(self.sim_list) == 0:
            # Lower bar
            self.save_btn.setEnabled(False)
            self.delete_btn.setEnabled(False)
            self.copy_btn.setEnabled(False)
            self.rename_btn.setEnabled(False)
            self.output_folder_btn.setEnabled(False)
            # Structure tab
            self.add_well_btn.setEnabled(False)
            self.add_barrier_btn.setEnabled(False)
            self.replace_well_btn.setEnabled(False)
            self.replace_barrier_btn.setEnabled(False)
            self.insert_well_btn.setEnabled(False)
            self.insert_barrier_btn.setEnabled(False)
            self.remove_selected_btn.setEnabled(False)
            self.remove_last_btn.setEnabled(False)
            self.remove_all_btn.setEnabled(False)
            # Layer thickness spinboxes
            self.barrier_ml_spb.setEnabled(False)
            self.well_ml_spb.setEnabled(False)
            self.barrier_nm_spb.setEnabled(False)
            self.well_nm_spb.setEnabled(False)
            # Simulation tab
            self.sim_Efield_btn.setEnabled(False)
            self.sim_run_btn.setEnabled(False)
            self.sim_plot_results_btn.setEnabled(False)
            self.sim_plot_structure_btn.setEnabled(False)
            # Absorption tab
            self.abs_run_btn.setEnabled(False)
            self.abs_plot_btn.setEnabled(False)
            # Transmission tab
            self.tra_plot_btn.setEnabled(False)
            # Photocurrent tab
            self.pc_run_btn.setEnabled(False)
            # Genetic algorithm tab
            self.ga_run_btn.setEnabled(False)
            # Automation tab
            self.auto_run_btn.setEnabled(False)

            self.ClearStructureTable()
            self.ClearSimPlot()
            self.ClearAbsPlot()
            self.ClearMaterialData()

        else:
            # current simulation
            sim = self.sim_list[self.simulation_cbox.currentIndex()]
            # If there are available simulations, some buttons must to be enabled
            # Lower bar
            self.save_btn.setEnabled(True)
            self.delete_btn.setEnabled(True)
            self.copy_btn.setEnabled(True)
            self.rename_btn.setEnabled(True)
            self.output_folder_btn.setEnabled(True)
            # Structure tab
            self.add_well_btn.setEnabled(True)
            self.add_barrier_btn.setEnabled(True)
            self.insert_well_btn.setEnabled(True)
            self.insert_barrier_btn.setEnabled(True)
            # Layer thickness spinboxes
            if self.adv_nm_layers_chkbx.checkState():
                self.barrier_nm_spb.setEnabled(True)
                self.well_nm_spb.setEnabled(True)
            else:
                self.barrier_ml_spb.setEnabled(True)
                self.well_ml_spb.setEnabled(True)

            if (
                len(sim.estrutura) &gt; 0
            ):  # If the structure is has layers, a simulation may be run
                # Simulation tab
                self.sim_run_btn.setEnabled(True)
                self.sim_plot_structure_btn.setEnabled(True)
                # Structure tab
                self.replace_well_btn.setEnabled(True)
                self.replace_barrier_btn.setEnabled(True)
                self.remove_selected_btn.setEnabled(True)
                self.remove_last_btn.setEnabled(True)
                self.remove_all_btn.setEnabled(True)
                # Genetic algorithm tab
                self.ga_run_btn.setEnabled(True)
                # Automation tab
                self.auto_run_btn.setEnabled(True)

                if sim.sim_ran is False:  # If the simulation has not yet been executed
                    # Simulation tab
                    self.sim_plot_results_btn.setEnabled(False)
                    # Absorption tab
                    self.abs_run_btn.setEnabled(False)
                    # Transmission tab
                    self.tra_plot_btn.setEnabled(False)
                    # Photocurrent tab
                    self.pc_run_btn.setEnabled(False)
                else:
                    # Simulation tab
                    self.sim_plot_results_btn.setEnabled(True)
                    # Absorption tab
                    self.abs_run_btn.setEnabled(True)
                    # Transmission tab
                    self.tra_plot_btn.setEnabled(True)
                    # Photocurrent tab
                    self.pc_run_btn.setEnabled(True)

                if (
                    sim.abs_ran is False
                ):  # If the absorption has not yet been calculated
                    self.abs_plot_btn.setEnabled(False)
                else:
                    self.abs_plot_btn.setEnabled(True)
            else:
                # Simulation tab
                self.sim_run_btn.setEnabled(False)
                # Structure tab
                self.replace_well_btn.setEnabled(False)
                self.replace_barrier_btn.setEnabled(False)
                self.remove_selected_btn.setEnabled(False)
                self.remove_last_btn.setEnabled(False)
                self.remove_all_btn.setEnabled(False)
                # Simulation tab
                self.sim_Efield_btn.setEnabled(False)
                self.sim_plot_results_btn.setEnabled(False)
                self.sim_plot_structure_btn.setEnabled(False)
                # Absorption tab
                self.abs_run_btn.setEnabled(False)
                # Genetic algorithm tab
                self.ga_run_btn.setEnabled(False)
                # Automation tab
                self.auto_run_btn.setEnabled(False)
            self.UpdateStructureTable()
            self.FillMaterialData()

    # Information about the materials used on the simulation, shown on the structure tab
    def ClearMaterialData(self):
        &#34;&#34;&#34;
        Removes the information about the materials from the Structure Tab. This
        function is called when there is no simulation.
        &#34;&#34;&#34;
        self.lbl_lattice_parameter_val.setText(&#34;&#34;)
        self.lbl_barrier_material_val.setText(&#34;&#34;)
        self.lbl_barrier_effective_mass_val.setText(&#34;&#34;)
        self.lbl_barrier_electronic_potential_val.setText(&#34;&#34;)
        self.lbl_barrier_non_parabolicity_val.setText(&#34;&#34;)
        self.lbl_well_material_val.setText(&#34;&#34;)
        self.lbl_well_effective_mass_val.setText(&#34;&#34;)
        self.lbl_well_electronic_potential_val.setText(&#34;&#34;)
        self.lbl_well_non_parabolicity_val.setText(&#34;&#34;)

    def FillMaterialData(self):
        &#34;&#34;&#34;
        Fills the structure tab with data for the selected materials.
        &#34;&#34;&#34;
        sim = self.sim_list[self.simulation_cbox.currentIndex()]
        self.lbl_lattice_parameter_val.setText(f&#34;{1E10*sim.latpar:.3f} Ang&#34;)
        self.lbl_barrier_material_val.setText(f&#34;{sim.barrier}&#34;)
        self.lbl_barrier_effective_mass_val.setText(f&#34;{sim.m_eff_ct_barrier:.3e}&#34;)
        self.lbl_barrier_electronic_potential_val.setText(
            f&#34;{1E3*sim.pot_barrier:.2f} meV&#34;
        )
        self.lbl_barrier_non_parabolicity_val.setText(f&#34;{sim.e_nonparab_barrier:.3e}&#34;)
        self.lbl_well_material_val.setText(f&#34;{sim.well}&#34;)
        self.lbl_well_effective_mass_val.setText(f&#34;{sim.m_eff_ct_well:.3e}&#34;)
        self.lbl_well_electronic_potential_val.setText(f&#34;{1E3*sim.pot_well:.2f} meV&#34;)
        self.lbl_well_non_parabolicity_val.setText(f&#34;{sim.e_nonparab_well:.3e}&#34;)

    # Tables ###########################################################################
    # Structure
    def InitializeStructTable(self):
        &#34;&#34;&#34;
        Initializes the table presenting the structure
        &#34;&#34;&#34;
        self.struct_table.setColumnCount(4)
        self.struct_table.setColumnWidth(0, 60)
        self.struct_table.setColumnWidth(1, 60)
        self.struct_table.setColumnWidth(2, 40)
        self.struct_table.setColumnWidth(3, 40)
        self.struct_table.move(0, 0)
        self.struct_table.setHorizontalHeaderLabels([&#34;Material&#34;, &#34;Feature&#34;, &#34;ML&#34;, &#34;nm&#34;])
        self.struct_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.struct_table.setSelectionBehavior(QAbstractItemView.SelectRows)

    def UpdateStructureTable(self):
        &#34;&#34;&#34;
        Function that updates the table at the structure tab. The table is erased every time and
        rewrites it all again usig information from sim.material and sim.estrutura.
        &#34;&#34;&#34;
        sim = self.sim_list[self.simulation_cbox.currentIndex()]
        self.struct_table.setRowCount(len(sim.material))
        for i, material in enumerate(sim.material):
            col0 = QTableWidgetItem(material)  # Creates the item
            col0.setTextAlignment(0x0084)  # Align h center, v baseline
            col1 = QTableWidgetItem(sim.feature[i])
            col1.setTextAlignment(0x0084)  # Align h center, v baseline
            col2 = QTableWidgetItem(f&#34;{sim.estrutura[i] / ( sim.latpar / 2):.0f}&#34;)
            col2.setTextAlignment(0x0082)  # Align h right, v baseline
            col3 = QTableWidgetItem(f&#34;{sim.estrutura[i] / NM:.3f}&#34;)
            col3.setTextAlignment(0x0082)  # Align h right, v baseline
            self.struct_table.setItem(i, 0, col0)
            self.struct_table.setItem(i, 1, col1)
            self.struct_table.setItem(i, 2, col2)
            self.struct_table.setItem(i, 3, col3)
            # Adjusts the line heigth
            self.struct_table.setRowHeight(i, 18)
            # Corrects the line index (without this correction, it starts from 1, instead of 0)
            self.struct_table.setVerticalHeaderItem(i, QTableWidgetItem(f&#34;{i}&#34;))
        # Adjusts the column width
        self.struct_table.setColumnWidth(0, 60)
        self.struct_table.setColumnWidth(1, 60)
        self.struct_table.setColumnWidth(2, 40)
        self.struct_table.setColumnWidth(3, 40)

    def ClearStructureTable(self):
        self.struct_table.setRowCount(0)

    # Simulation data
    def InitializeDataTable(self):
        &#34;&#34;&#34;
        Initializes the table presenting the results
        &#34;&#34;&#34;
        self.data_table.setColumnCount(1)
        self.data_table.setColumnWidth(0, 120)
        # self.struct_table.setColumnWidth(1, 60)
        # self.struct_table.setColumnWidth(2, 40)
        # self.struct_table.setColumnWidth(3, 40)
        self.data_table.move(0, 0)
        # Definition of the header labels
        h_lbls = [&#34;Energy (meV)&#34;]
        self.data_table.setHorizontalHeaderLabels(h_lbls)
        self.data_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.data_table.setSelectionBehavior(QAbstractItemView.SelectRows)

    def UpdateDataTable(self):
        &#34;&#34;&#34;
        Function that updates the table at the data tab. The table is erased every time and
        rewritten with data from the latest simulation
        &#34;&#34;&#34;
        self.ClearDataTable()
        # Gets the current selected simulation
        sim = self.sim_list[self.simulation_cbox.currentIndex()]

        self.data_table.setRowCount(len(sim.sim_Energias))
        for i, energia in enumerate(sim.sim_Energias):

            col0 = QTableWidgetItem(f&#34;{energia * 1000:.3f} meV&#34;)  # Creates the item
            col0.setTextAlignment(0x0084)  # Align h center, v baseline
            # col1 = QTableWidgetItem(sim.feature[i])
            # col1.setTextAlignment(0x0084)  # Align h center, v baseline
            # col2 = QTableWidgetItem(f&#34;{sim.estrutura[i] / ( sim.latpar / 2):.0f}&#34;)
            # col2.setTextAlignment(0x0082)  # Align h right, v baseline
            # col3 = QTableWidgetItem(f&#34;{sim.estrutura[i] / NM:.3f}&#34;)
            # col3.setTextAlignment(0x0082)  # Align h right, v baseline
            self.data_table.setItem(i, 0, col0)
            # self.struct_table.setItem(i, 1, col1)
            # self.struct_table.setItem(i, 2, col2)
            # self.struct_table.setItem(i, 3, col3)
            # Adjusts the line heigth
            self.data_table.setRowHeight(i, 18)
            # Corrects the line index (without this correction, it starts from 1, instead of 0)
            self.data_table.setVerticalHeaderItem(i, QTableWidgetItem(f&#34;{i}&#34;))
        # Adjusts the column width
        self.data_table.setColumnWidth(0, 120)
        # self.struct_table.setColumnWidth(1, 60)
        # self.struct_table.setColumnWidth(2, 40)
        # self.struct_table.setColumnWidth(3, 40)

    def ClearDataTable(self):
        self.data_table.setRowCount(0)

    # Plots ############################################################################
    def CreatePlots(self):
        &#34;&#34;&#34;
        Initial configuration of the plots
        &#34;&#34;&#34;
        # Simulation
        self.sim_fig = plt.figure()
        self.sim_canvas = FigureCanvas(self.sim_fig)
        self.sim_plot_layout.addWidget(self.sim_canvas)
        self.sim_nav = NavigationToolbar(self.sim_canvas, self.sim_tab)
        self.sim_plot_layout.addWidget(self.sim_nav)
        self.sim_subplot = self.sim_fig.add_subplot(111)
        self.sim_subplot.grid(True, axis=&#34;y&#34;)
        self.show()
        # Absorption
        self.abs_fig = plt.figure()
        self.abs_canvas = FigureCanvas(self.abs_fig)
        self.abs_plot_layout.addWidget(self.abs_canvas)
        self.abs_nav = NavigationToolbar(self.abs_canvas, self.abs_tab)
        self.abs_plot_layout.addWidget(self.abs_nav)
        self.abs_subplot = self.abs_fig.add_subplot(111)
        self.abs_subplot.grid(True, axis=&#34;both&#34;)
        self.show()
        # Transmission
        self.tra_fig = plt.figure()
        # self.tra_fig, self.tra_ax = plt.subplots(nrows=1, ncols=1)
        self.tra_canvas = FigureCanvas(self.tra_fig)
        self.tra_plot_layout.addWidget(self.tra_canvas)
        self.tra_nav = NavigationToolbar(self.tra_canvas, self.transmission_tab)
        self.tra_plot_layout.addWidget(self.tra_nav)
        self.tra_subplot = self.tra_fig.add_subplot(111)
        self.tra_subplot.grid(True, axis=&#34;both&#34;)
        self.show()
        # Photocurrent
        self.pc_fig = plt.figure()
        self.pc_canvas = FigureCanvas(self.pc_fig)
        self.pc_plot_layout.addWidget(self.pc_canvas)
        self.pc_nav = NavigationToolbar(self.pc_canvas, self.photocurrent_tab)
        self.pc_plot_layout.addWidget(self.pc_nav)
        self.pc_subplot = self.pc_fig.add_subplot(111)
        self.pc_subplot.grid(True, axis=&#34;both&#34;)
        self.show()
        # Genetic algorithm
        self.ga_fig = plt.figure()
        self.ga_canvas = FigureCanvas(self.ga_fig)
        self.ga_plot_layout.addWidget(self.ga_canvas)
        self.ga_nav = NavigationToolbar(self.ga_canvas, self.ga_tab)
        self.ga_plot_layout.addWidget(self.ga_nav)
        self.ga_subplot = self.ga_fig.add_subplot(111)
        self.ga_subplot.grid(True, axis=&#34;both&#34;)
        self.show()

    # Structure and Wave Function
    def PlotStructure(self, sim=None):
        &#34;&#34;&#34;
        Function that interprets the structure data and create arrays to plot the graph.
        It is necessary to analyze the position and potential arrays in order to correctly plot the
        structure. In the interface between two materials the position is the same, but the energy
        is different. If the material is repeated, but the position is different, there is no need
        to create another point.
        &#34;&#34;&#34;
        # If this function is called without a specified sim, it gets the selected one from the
        # interface combobox
        if sim is None:
            try:  # Gets the current selected simulation
                sim = self.sim_list[self.simulation_cbox.currentIndex()]
            except:
                print(&#34;There is no simulation to choose from, create one first.&#34;)
                return

        self.ClearSimPlot()
        if len(sim.estrutura) &lt; 1:  # Only continue if there is a structure
            return
        # Creating the x and energy arrays  just for the plot
        sim.x_graf = np.array([0])
        sim.v_graf = np.array([sim.pot[0]])

        # Going through the layers and creating the arrays iteratively
        for i, en in enumerate(sim.pot):
            if (
                en == sim.v_graf[-1]
            ):  # If this layer has the same energy as the previous one
                sim.x_graf = np.append(sim.x_graf, [sim.x_graf[-1] + sim.estrutura[i]])
                sim.v_graf = np.append(sim.v_graf, [en])
            else:
                sim.x_graf = np.append(
                    sim.x_graf, [sim.x_graf[-1], sim.x_graf[-1] + sim.estrutura[i]]
                )
                sim.v_graf = np.append(sim.v_graf, [en, en])

        # Changing x and y to [nm] and [meV]
        sim.x_graf = 1.0e9 * sim.x_graf
        sim.v_graf = 1.0e3 * sim.v_graf

        # Centering the structure around 0
        # sim.x_graf = sim.x_graf - (np.max(sim.x_graf) - np.min(sim.x_graf)) / 2.0

        layers = len(sim.estrutura)
        central_layer = self.sim_central_layer_spb.value()
        &#34;&#34;&#34;
        This part of the code was used to put the 0 of the x-axis in the center of a 
        layer, but this doesn&#39;t work for Pedro&#39;s photocurrent calculations, therefore
        the 0 will be at the interfaces.
        # Creating the x-axis array - the x-axis 0 is centered in the target layer
        if central_layer &lt; 0:
            x0 = 0.0
        else:
            if (
                central_layer &gt; layers - 1
            ):  # In case the number of the layer exceeds the limit
                central_layer = layers - 1
            left_x_central = np.sum(
                sim.estrutura[0:central_layer]
            )  # Thickness of layers before
            central_thickness = sim.estrutura[
                central_layer
            ]  # Thickness of target layers
            x0 = -left_x_central - central_thickness / 2.0
        x0 = x0 / NM
        sim.x_graf = sim.x_graf + x0
        &#34;&#34;&#34;
        if central_layer &lt;= 0:
            x0 = 0.0
        else:
            # In case the number of the layer exceeds the limit
            if central_layer &gt; layers:
                central_layer = layers
            # Thickness of layers on the left side of the target interface
            x0 = -np.sum(sim.estrutura[0:central_layer])
        x0 = x0 / NM
        sim.x_graf = sim.x_graf + x0

        &#34;&#34;&#34;
        Plots the structure using arrays that were created by the UpdateStructure. Doesn&#39;t erase
        the graph, in order to allow comparison between two structures
        &#34;&#34;&#34;
        # sim = self.sim_list[self.simulation_cbox.currentIndex()]
        self.sim_subplot.plot(sim.x_graf, sim.v_graf)  # x in [nm] and y in [meV]
        self.sim_subplot.set_xlabel(&#34;Length (nm)&#34;)
        self.sim_subplot.set_ylabel(&#34;Energy (meV)&#34;)
        self.sim_subplot.set_xbound(sim.x_graf[0] - 0.2, sim.x_graf[-1] + 0.2)
        self.sim_subplot.set_ybound(np.min(sim.v_graf) - 50, np.max(sim.v_graf) + 100)
        self.sim_fig.tight_layout()
        self.sim_canvas.draw()

    def PlotSimResults(self, sim=None):
        &#34;&#34;&#34;
        Plost the results from ResultadoWF.
        &#34;&#34;&#34;
        # If this function is called without a specified sim, it gets the selected one from the
        # interface combobox
        if sim is None:
            try:  # Gets the current selected simulation
                sim = self.sim_list[self.simulation_cbox.currentIndex()]
            except:
                print(&#34;There is no simulation to choose from, create one first.&#34;)
                return

        # Gets the selected simulation
        # sim = self.sim_list[self.simulation_cbox.currentIndex()]
        self.sim_subplot.grid(True, axis=&#34;y&#34;)
        # Plots the probability density
        for result in sim.sim_ResultadoWF:
            self.sim_subplot.plot(result[0, :] / NM, result[3, :] * 1.0e3)
            # self.subplot_sim.plot(result[:, 0] / 1.0E9, result[:, 3] * 1.0E0)
        self.sim_canvas.draw()

    def ClearSimPlot(self):
        &#34;&#34;&#34;
        Clears the simulation plot.
        &#34;&#34;&#34;
        self.sim_fig.clf()
        self.sim_fig.tight_layout()
        self.sim_subplot = self.sim_fig.add_subplot(111)
        self.sim_canvas.draw()

    # Absorption
    def PlotAbsorption(self, sim=None):
        &#34;&#34;&#34;
        Plots the results from the absorption of the selected simulation.
        &#34;&#34;&#34;
        # If this function is called without a specified sim, it gets the selected one
        # from the interface combobox
        if sim is None:
            try:  # Gets the current selected simulation
                sim = self.sim_list[self.simulation_cbox.currentIndex()]
            except:
                print(&#34;There is no simulation to choose from, create one first.&#34;)
                return

        self.abs_subplot.plot(sim.abs_energy_axis, sim.abs_result)
        self.abs_subplot.set_xlabel(&#34;Energy (eV)&#34;)
        self.abs_subplot.set_ylabel(&#34;Absorption (u.a.)&#34;)
        self.abs_fig.tight_layout()
        self.abs_subplot.grid(True, axis=&#34;both&#34;)
        self.abs_canvas.draw()

    def ClearAbsPlot(self):
        &#34;&#34;&#34;
        Clears the absorption plot.
        &#34;&#34;&#34;
        self.abs_fig.clf()
        self.abs_fig.tight_layout()
        self.abs_subplot = self.abs_fig.add_subplot(111)
        self.abs_canvas.draw()

    # Transmission
    def PlotTransmission(self, sim=None):
        &#34;&#34;&#34;
        Plots the transmission. The transmission is only calculated after simulation was
        run.
        &#34;&#34;&#34;
        # If this function is called without a specified sim, it gets the selected one
        # from the interface combobox
        if sim is None:
            try:  # Gets the current selected simulation
                sim = self.sim_list[self.simulation_cbox.currentIndex()]
            except:
                print(&#34;There is no simulation to choose from, create one first.&#34;)
                return

        self.tra_subplot.plot(sim.sim_VecEnergy * 1.0e3, sim.sim_Transmission)
        self.tra_subplot.set_xlabel(&#34;Energy (eV)&#34;)
        self.tra_subplot.set_ylabel(&#34;Transmission (u.a.)&#34;)
        self.tra_fig.tight_layout()
        self.tra_subplot.grid(True, axis=&#34;both&#34;)
        # self.tra_subplot.set_yscale(&#34;log&#34;)
        self.tra_canvas.draw()

    def ClearTransPlot(self):
        &#34;&#34;&#34;
        Clears the Transmission plot.
        &#34;&#34;&#34;
        self.tra_fig.clf()
        self.tra_fig.tight_layout()
        self.tra_subplot = self.tra_fig.add_subplot(111)
        self.tra_canvas.draw()

    # Photocurrent
    def PlotPhotocurrent(self, sim=None):
        &#34;&#34;&#34;
        Plots the photocurrent. The photocurrent is only calculated after simulation was
        run.
        &#34;&#34;&#34;
        # If this function is called without a specified sim, it gets the selected one
        # from the interface combobox
        if sim is None:
            try:  # Gets the current selected simulation
                sim = self.sim_list[self.simulation_cbox.currentIndex()]
            except:
                print(&#34;There is no simulation to choose from, create one first.&#34;)
                return

        self.pc_subplot.plot(sim.sim_Photocurrent[0], sim.sim_Photocurrent[1])
        self.pc_subplot.set_xlabel(&#34;Energy (eV)&#34;)
        self.pc_subplot.set_ylabel(&#34;Photocurrent (u.a.)&#34;)
        self.pc_fig.tight_layout()
        self.pc_subplot.grid(True, axis=&#34;both&#34;)
        # self.pc_subplot.set_yscale(&#34;log&#34;)
        self.pc_canvas.draw()

    def ClearPhotocurrentPlot(self):
        &#34;&#34;&#34;
        Clears the photocurrent plot.
        &#34;&#34;&#34;
        self.pc_fig.clf()
        self.pc_fig.tight_layout()
        self.pc_subplot = self.pc_fig.add_subplot(111)
        self.pc_canvas.draw()

    # File inputs and outputs ##########################################################
    def ChooseOutputFolder(self):
        &#34;&#34;&#34;
        Prompts the user to choose the simulation data output folder. Inside this folder, there will
        be a folder with the simulation title.
        &#34;&#34;&#34;
        folder = QFileDialog.getExistingDirectory()
        if (
            folder
        ):  # If the output folder was properly selects, add the os separator to it
            os.path.join(folder, &#34;&#34;)  # OS independent separator
        self.output_folder_line.setText(folder)

        sim = self.sim_list[self.simulation_cbox.currentIndex()]
        sim.output_folder = self.output_folder_line.text()

    def SaveSimulation(self):
        &#34;&#34;&#34;
        Saves the structure, simulation and absorption parameters.
        &#34;&#34;&#34;
        sim = self.sim_list[self.simulation_cbox.currentIndex()]
        try:
            save_dir = os.path.join(sim.output_folder, f&#34;{sim.title}.qwsim&#34;)
            # print(f&#39;save_dir: {save_dir}&#39;)
            file, _ = QFileDialog.getSaveFileName(
                self,
                caption=&#34;Save structure and simulation parameters&#34;,
                directory=save_dir,
                filter=self.tr(&#34;*.qwsim&#34;),
            )

            output_file = open(file, &#34;wb&#34;)
            pickle.dump(sim, output_file)
            output_file.close()
        except:
            print(&#34;Couldn&#39;t save the structure&#34;)
            # If the user doesn&#39;t choose a filename, closing the interface, do nothing
            return

    def LoadSimulation(self):
        &#34;&#34;&#34;
        Loads structure and simulation data from a file
        &#34;&#34;&#34;
        try:  # Returns a tuple
            file, _ = QFileDialog.getOpenFileName(
                self, &#34;Loads the structure and simulation data&#34;, self.tr(&#34;*.qwsim&#34;)
            )
            input_file = open(file, &#34;rb&#34;)
            sim = pickle.load(input_file)

            self.sim_list.append(sim)
            self.simulation_cbox.setCurrentIndex(len(self.sim_list) - 1)
            self.UpdateStructureTable()
            self.UpdateSimList()
            self.UpdateLayerCount()
            # If an structure was saved, plot it
            try:  # The try-except is to avoid errors in case sim.structure doesn&#39;t exist
                if len(sim.estrutura) &gt; 0:
                    self.PlotStructure(sim)
            except:
                pass
            # If a simulation result was saved, plot it
            try:
                if sim.sim_ran:
                    self.PlotSimResults(sim)
            except:
                pass
            # If an absorption result was saved, plot it
            try:
                if sim.abs_ran:
                    self.PlotAbsorption(sim)
            except:
                pass
            self.UpdateInterface()

        except:
            # If an error happens upon opening the file, the function just returns False.
            print(&#34;Couldn&#39;t load the structure&#34;)
            return

    def CreateOutputFolder(self, sim):
        &#34;&#34;&#34;
        Checks whether the selected output folder exists or must be created
        &#34;&#34;&#34;
        # Defines the output folder based on the simulation title
        # output_folder = str(self.output_folder_line.text())
        output_folder = sim.output_folder
        # If the folder was not chosen, just get the file execution path
        if not output_folder:
            output_folder = os.path.dirname(os.path.abspath(__file__))
        # If the menu checkbox is checked (it is, by default) create a folder with the same name as
        # the simulation
        if self.adv_new_folder_chkbx.isChecked:
            output_folder = os.path.join(output_folder, sim.title)

        return output_folder

    def SaveSimOutput(self, sim):
        &#34;&#34;&#34;
        Based on the interface&#39;s checkboxes, saves the simulation output
        &#34;&#34;&#34;
        output_folder = self.CreateOutputFolder(sim)

        # To avoid repetition of the &#34;all checkbox&#34;
        save_all = self.sim_files_all_chkbx.isChecked()

        # After the end of the calculations, save the result in text files if desired
        if (
            save_all
            or self.sim_files_effm_chkbx.isChecked()
            or self.sim_files_energies_chkbx.isChecked()
            or self.sim_files_npe_chkbx.isChecked()
            or self.sim_files_pot_chkbx.isChecked()
            or self.sim_files_wf_chkbx.isChecked()
            or self.sim_files_x_chkbx.isChecked()
        ):
            data_folder = os.path.join(output_folder, &#34;Data&#34;)

            # if the folder to save the data doesn&#39;t exist, create it
            if not os.path.exists(data_folder):
                os.makedirs(data_folder)

        if save_all or self.sim_files_x_chkbx.isChecked():
            np.savetxt(os.path.join(data_folder, &#34;X Axis.txt&#34;), sim.sim_x, newline=&#34;\n&#34;)

        if save_all or self.sim_files_pot_chkbx.isChecked():
            np.savetxt(
                os.path.join(data_folder, &#34;Electrical Potential.txt&#34;),
                sim.sim_pot,
                newline=&#34;\n&#34;,
            )

        if save_all or self.sim_files_effm_chkbx.isChecked():
            np.savetxt(
                os.path.join(data_folder, &#34;Effective Mass.txt&#34;),
                sim.sim_effm_cte,
                newline=&#34;\n&#34;,
            )

        if save_all or self.sim_files_npe_chkbx.isChecked():
            np.savetxt(
                os.path.join(data_folder, &#34;Non-Parabolicity.txt&#34;),
                sim.sim_npe,
                newline=&#34;\n&#34;,
            )

        if save_all or self.sim_files_energies_chkbx.isChecked():
            np.savetxt(os.path.join(data_folder, &#34;Autoenergias.txt&#34;), sim.sim_Energias)

        if save_all or self.sim_files_wf_chkbx.isChecked():
            PastaWave = os.path.join(data_folder, &#34;Wave Functions&#34;)
            if not os.path.exists(PastaWave):
                os.makedirs(PastaWave)
            for a in range(len(sim.sim_Energias)):
                fname = f&#34;WF_E{a}_{sim.sim_Energias[a]:02.6f}.txt&#34;
                # The transposed is print, so that the WF is in a column, not row
                np.savetxt(os.path.join(PastaWave, fname), sim.sim_ResultadoWF[a].T)

    def SaveTransmissionOutput(self, sim):
        &#34;&#34;&#34;
        Based on the interface&#39;s checkboxes, saves the Transmission output
        &#34;&#34;&#34;
        output_folder = self.CreateOutputFolder(sim)

        # After the end of the calculations, save the result in text files if desired
        if (
            self.sim_files_all_chkbx.isChecked()
            or self.sim_files_trans_chkbx.isChecked()
        ):
            data_folder = os.path.join(output_folder, &#34;Data&#34;)

            # if the folder to save the data doesn&#39;t exist, create it
            if not os.path.exists(data_folder):
                os.makedirs(data_folder)

            output = np.column_stack((sim.sim_VecEnergy, sim.sim_Transmission))
            output_file = os.path.join(data_folder, &#34;Transmission Spectrum.txt&#34;)
            np.savetxt(output_file, output)

    def SavePhotocurrentOutput(self, sim):
        &#34;&#34;&#34;
        Based on the interface&#39;s checkboxes, saves the Transmission output
        &#34;&#34;&#34;
        output_folder = self.CreateOutputFolder(sim)

        # After the end of the calculations, save the result in text files if desired
        if self.sim_files_all_chkbx.isChecked() or self.sim_files_pc_chkbox.isChecked():
            data_folder = os.path.join(output_folder, &#34;Data&#34;)

            # if the folder to save the data doesn&#39;t exist, create it
            if not os.path.exists(data_folder):
                os.makedirs(data_folder)

            output = sim.sim_Photocurrent
            output_file = os.path.join(data_folder, &#34;Photocurrent Spectrum.txt&#34;)
            np.savetxt(output_file, output)

    def SaveGUIConfigFile(self):
        &#34;&#34;&#34;
        Saves all the values and settings on the interface to the &#34;interface.cfg&#34; file.
        This is meant to be a easy way of saving the default settings, so that the user doesn&#39;t need
        to change the values every time the software is opened, nor needs to manually edit the
        config file.
        The values must be in string format.
        &#34;&#34;&#34;
        # Reads the configuration defaults from the &#34;interface.cfg&#34; file:
        cfg = configparser.ConfigParser()
        file = os.path.join(self.base_path, &#34;interface.cfg&#34;)
        cfg.read(file)

        # Structure tab
        # Saves only the values of nm or ml, depending on the checkbox state
        if self.adv_nm_layers_chkbx.checkState():
            cfg[&#34;stru&#34;][&#34;barrier_nm&#34;] = f&#34;{self.barrier_nm_spb.value()}&#34;
            cfg[&#34;stru&#34;][&#34;well_nm&#34;] = f&#34;{self.well_nm_spb.value()}&#34;
        else:
            cfg[&#34;stru&#34;][&#34;barrier_ml&#34;] = f&#34;{self.barrier_ml_spb.value()}&#34;
            cfg[&#34;stru&#34;][&#34;well_ml&#34;] = f&#34;{self.well_ml_spb.value()}&#34;

        # Simulation tab
        cfg[&#34;simu&#34;][&#34;E0&#34;] = f&#34;{self.sim_E0_spb.value()}&#34;
        cfg[&#34;simu&#34;][&#34;dE&#34;] = f&#34;{self.sim_dE_spb.value()}&#34;
        cfg[&#34;simu&#34;][&#34;Ef&#34;] = f&#34;{self.sim_Ef_spb.value()}&#34;
        if self.adv_nm_layers_chkbx.checkState():
            cfg[&#34;simu&#34;][&#34;dx_nm&#34;] = f&#34;{self.sim_dx_nm_spb.value()}&#34;
        else:
            cfg[&#34;simu&#34;][&#34;dx_ml&#34;] = f&#34;{self.sim_dx_ml_spb.value()}&#34;
        cfg[&#34;simu&#34;][&#34;Efield&#34;] = f&#34;{self.sim_Efield_spb.value()}&#34;
        cfg[&#34;simu&#34;][&#34;central_layer&#34;] = f&#34;{self.sim_central_layer_spb.value()}&#34;
        # Checkboxes
        cfg[&#34;simu&#34;][&#34;output_all&#34;] = (
            &#34;True&#34; if self.sim_files_all_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;simu&#34;][&#34;output_effm&#34;] = (
            &#34;True&#34; if self.sim_files_effm_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;simu&#34;][&#34;output_energies&#34;] = (
            &#34;True&#34; if self.sim_files_energies_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;simu&#34;][&#34;output_npe&#34;] = (
            &#34;True&#34; if self.sim_files_npe_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;simu&#34;][&#34;output_pot&#34;] = (
            &#34;True&#34; if self.sim_files_pot_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;simu&#34;][&#34;output_trans&#34;] = (
            &#34;True&#34; if self.sim_files_trans_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;simu&#34;][&#34;output_wf&#34;] = (
            &#34;True&#34; if self.sim_files_wf_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;simu&#34;][&#34;output_x&#34;] = (
            &#34;True&#34; if self.sim_files_x_chkbx.checkState() else &#34;False&#34;
        )

        # Absorption tab
        cfg[&#34;abso&#34;][&#34;initial_WF&#34;] = f&#34;{self.abs_init_wf_spb.value()}&#34;
        cfg[&#34;abso&#34;][&#34;lorz_broad&#34;] = f&#34;{self.abs_broadening_spb.value()}&#34;
        cfg[&#34;abso&#34;][&#34;E0&#34;] = f&#34;{self.abs_E0_spb.value()}&#34;
        cfg[&#34;abso&#34;][&#34;dE&#34;] = f&#34;{self.abs_dE_spb.value()}&#34;
        cfg[&#34;abso&#34;][&#34;Ef&#34;] = f&#34;{self.abs_Ef_spb.value()}&#34;

        # Transmission tab

        # Photocurrent tab
        cfg[&#34;phot&#34;][&#34;E0&#34;] = f&#34;{self.pc_E0_spb.value()}&#34;
        cfg[&#34;phot&#34;][&#34;dE&#34;] = f&#34;{self.pc_dE_spb.value()}&#34;
        cfg[&#34;phot&#34;][&#34;Ef&#34;] = f&#34;{self.pc_Ef_spb.value()}&#34;

        # Genetic Algorithm tab
        cfg[&#34;gene&#34;][&#34;iterations&#34;] = f&#34;{self.ga_iter_spb.value():d}&#34;
        cfg[&#34;gene&#34;][&#34;population&#34;] = f&#34;{self.ga_pop_spb.value():d}&#34;
        cfg[&#34;gene&#34;][&#34;target_E&#34;] = f&#34;{self.ga_tgt_en_spb.value()}&#34;
        cfg[&#34;gene&#34;][&#34;target_E_margin&#34;] = f&#34;{self.ga_tgt_en_margin_spb.value()}&#34;
        cfg[&#34;gene&#34;][&#34;goal&#34;] = f&#34;{self.ga_goal_cbox.currentIndex():d}&#34;

        # Automation tab
        cfg[&#34;auto&#34;][&#34;target_layer&#34;] = f&#34;{self.auto_layer_spb.value():d}&#34;
        cfg[&#34;auto&#34;][&#34;thickness_initial&#34;] = f&#34;{self.auto_init_spb.value()}&#34;
        cfg[&#34;auto&#34;][&#34;thickness_step&#34;] = f&#34;{self.auto_step_spb.value()}&#34;
        cfg[&#34;auto&#34;][&#34;thickness_final&#34;] = f&#34;{self.auto_final_spb.value()}&#34;

        # Data tab

        # Advanced tab
        cfg[&#34;adva&#34;][&#34;create_new_folder&#34;] = (
            &#34;True&#34; if self.adv_new_folder_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;adva&#34;][&#34;use_nanometers&#34;] = (
            &#34;True&#34; if self.adv_nm_layers_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;adva&#34;][&#34;autorun_abs&#34;] = (
            &#34;True&#34; if self.adv_autorun_abs_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;adva&#34;][&#34;autorun_abs_initial_WF&#34;] = f&#34;{self.adv_wf0_spb.value()}&#34;
        cfg[&#34;adva&#34;][&#34;autorun_trans&#34;] = (
            &#34;True&#34; if self.adv_autorun_trans_chkbx.checkState() else &#34;False&#34;
        )
        cfg[&#34;adva&#34;][&#34;interface_to_split&#34;] = f&#34;{self.adv_split_layer_spb.value()}&#34;
        cfg[&#34;adva&#34;][&#34;method&#34;] = f&#34;{self.adv_method_cbox.currentIndex()}&#34;

        # Saves the configuration file
        with open(file, &#34;w&#34;) as configfile:
            cfg.write(configfile)

    # Run the calculations #############################################################
    # Absorption
    def RunAbsorption(self, sim=None):
        &#34;&#34;&#34;
        Calculates the structure&#39;s absorption spectra, the dipole moment, oscilator strenght and
        delta energy between the absorption peaks and the reference wavefunction (wf_0).
        &#34;&#34;&#34;
        # If this function is called without a specified sim, it gets the selected one from the
        # interface combobox
        if sim is None:
            try:  # Gets the current selected simulation
                sim = self.sim_list[self.simulation_cbox.currentIndex()]
            except:
                print(&#34;There is no simulation to choose from, create one first.&#34;)
                return
        # Checks whether there are at least two wavefunctions, in order to calculate the absorption.
        if len(sim.sim_Energias) &lt; 2:
            print(&#34;Cannot calculate absorption if there are less than 2 wavefunctions.&#34;)
            return
        # Collecting the relevant data from the GUI
        wf_0_index = int(self.abs_init_wf_spb.value())
        E0 = self.abs_E0_spb.value()
        Ef = self.abs_Ef_spb.value()
        dE = self.abs_dE_spb.value()
        # Linewidth broadening of the lorentzian. From &#34;Van Hove singularities in intersubband
        # transitions in multiquantum well photodetectors&#34; doi.org/10.1016/j.infrared.2006.10.016
        broadening = self.abs_broadening_spb.value()

        # Gets the choosen simulation
        # sim = self.sim_list[self.simulation_cbox.currentIndex()]
        sim.CalcAbs(wf_0_index, E0, Ef, dE, broadening)

        # Saving the absorption output to files
        output_folder = (
            sim.output_folder
        )  # As defined when the sim was created or &#34;change folder&#34;
        # Defines the output folder based on the simulation title
        if self.adv_new_folder_chkbx.isChecked:
            output_folder = os.path.join(output_folder, sim.title)
        # Saves in a folder called &#34;Absorption&#34;
        output_folder = os.path.join(output_folder, &#34;Absorption&#34;)
        if not os.path.exists(output_folder):
            os.makedirs(output_folder)

        try:
            data = np.column_stack(
                (sim.abs_delta_E, sim.abs_dipole, sim.abs_osc_strength)
            )
            filename = f&#34;DeltaE_DipoloEletrico_ForcadeOscilador_E{wf_0_index:01d}.txt&#34;
            np.savetxt(os.path.join(output_folder, filename), data)
        except:
            print(&#34;Could not save absorption results&#34;)

        try:
            data = np.column_stack((sim.abs_energy_axis, sim.abs_result))
            filename = f&#34;Absorcao_E{wf_0_index:01d}.txt&#34;
            np.savetxt(os.path.join(output_folder, filename), data)
        except:
            print(&#34;Could not save absorption results&#34;)

        # Plot the absorption and update the interface
        self.PlotAbsorption(sim)
        self.UpdateInterface()

    def RunAutomation(self):
        &#34;&#34;&#34;
        Creates an automation changing the thickness of the target layer by the values
        in the range defined by the user in the GUI
        &#34;&#34;&#34;
        # Gets the base simulation, which will be modified by the automated steps
        base_sim = self.sim_list[self.simulation_cbox.currentIndex()]

        # Obtaining the target range of thicknesses
        th_init = self.auto_init_spb.value()
        th_step = self.auto_step_spb.value()
        th_final = self.auto_final_spb.value()
        # List of thicknesses
        th_list = np.arange(th_init, th_final + th_step, th_step, dtype=float)

        # Defining whether the thickness is in nanometers or monolayers
        if (
            self.adv_nm_layers_chkbx.checkState()
        ):  # If user wants nanometers, use value as is
            th_unit = &#34;nm&#34;
        else:  # else, calculate dx as a multiple of monolayer = latpar/2
            # Correcting the units, if the value was entered in monolayers
            th_unit = &#34;ml&#34;
            th_list = th_list * base_sim.latpar / 2

        # Gets the index of the layer that must be modified
        tgt_layer = self.auto_layer_spb.value()
        # The target layer must exist. In case the structure doesn&#39;t have the defined layer, correct
        if tgt_layer &lt; 0:
            tgt_layer = 0
        elif tgt_layer &gt; len(base_sim.estrutura) - 1:
            tgt_layer = len(base_sim.estrutura) - 1

        slist = []
        # For each thickness
        for th in th_list:
            # Creates a copy of the original simulation
            new_sim = deepcopy(base_sim)
            # Puts it into the simulations list
            self.sim_list.append(new_sim)
            # Puts it into a list just for the multiprocessing
            slist.append(new_sim)
            # Changes the title based on the title of the base simulation and the modification
            new_sim.title = base_sim.title + f&#34; {th:.3f}{th_unit}&#34;
            # Changes the thickness of the target layer
            if new_sim.feature[tgt_layer] == &#34;Well&#34;:
                new_sim.ReplaceWell(th, tgt_layer)
            else:
                new_sim.ReplaceBarrier(th, tgt_layer)
            self.RunSimulation(new_sim)

        # cores = cpu_count()
        # p = Pool(processes=cores)
        # p = Pool(processes=1)
        # p.map(self.RunASim, slist)
        # with Pool(processes=cores) as p:
        #     for i, _ in enumerate(p.imap_unordered(self.RunASim, slist)):
        #         print(i)

        self.UpdateStructureTable()
        self.UpdateSimList()

    # Simulation
    def RunSimulation(self, sim=None):
        &#34;&#34;&#34;
        This function is a copy of &#34;Run&#34; but it takes the simulation as an argument
        instead of getting the selected simulation from the combobox.
        &#34;&#34;&#34;
        # If this function is called without a specified sim, it gets the selected one
        # from the interface combobox
        if sim is None:
            try:  # Gets the current selected simulation
                sim = self.sim_list[self.simulation_cbox.currentIndex()]
            except:
                print(&#34;There is no simulation to choose from, create one first.&#34;)
                return

        # Obtaining the target range of energies
        E0 = self.sim_E0_spb.value()
        Ef = self.sim_Ef_spb.value()
        dE = self.sim_dE_spb.value()

        # Reads the value of dx from the interface
        if self.adv_nm_layers_chkbx.checkState():
            # If user wants nanometers, use value as is
            dx = self.sim_dx_nm_spb.value()
            dx_unit = &#34;nm&#34;
        else:  # else, calculate dx as a multiple of monolayer = latpar/2
            dx = self.sim_dx_ml_spb.value()
            dx_unit = &#34;ml&#34;

        # From the interface, defines the interface of the wavefunction split
        split_i = self.adv_split_layer_spb.value()

        # From the structure tab, gets the index of the central layer
        central_layer = self.sim_central_layer_spb.value()

        # The method chosen by the user to perform the calculations
        # Methods avaliable:
        # 0 - &#34;Numerov - For&#34;
        # 1 - &#34;Numerov - Split&#34;
        # 2 - &#34;Numerov - Arrays&#34;
        # 3 - &#34;TMM&#34;
        # 4 - &#34;TMM - Split&#34;
        wf_method = self.adv_method_cbox.currentIndex()

        # Timing
        t_start_run = time.time()

        # Runs the calculations with information gathered from the interface and stored
        # at a &#34;sim&#34;.
        # Sim is the selected simulation, containing all relevant data
        sim.RunSim(wf_method, split_i, E0, Ef, dE, dx, dx_unit, central_layer)
        # Timing
        print(f&#34;Total time: {time.time() - t_start_run:.3f} s&#34;)

        self.SaveSimOutput(sim)
        self.PlotSimResults(sim)
        self.UpdateInterface()
        self.UpdateDataTable()
        # If the user wants, automatically calculate the absorption, transmission or
        # photocurrent after the main simulation
        if self.sim_autorun_abs_chkbx.checkState():
            self.RunAbsorption(sim)
        if self.sim_autorun_tra_chkbx.checkState():
            self.RunTransmission(sim)
        if self.sim_autorun_pc_chkbx.checkState():
            self.RunPhotocurrent(sim)

    # Transmission
    def RunTransmission(self, sim=None):
        &#34;&#34;&#34;
        Performs the calculation of the transmission and displays it on the graph.
        &#34;&#34;&#34;
        # If this function is called without a specified sim, it gets the selected one
        # from the interface combobox
        if sim is None:
            try:  # Gets the current selected simulation
                sim = self.sim_list[self.simulation_cbox.currentIndex()]
            except:
                print(&#34;There is no simulation to choose from, create one first.&#34;)
                return

        sim.Transmission()

        self.PlotTransmission(sim)
        self.SaveTransmissionOutput(sim)

    def RunPhotocurrent(self, sim=None):
        &#34;&#34;&#34;
        Performs the calculation of the Photocurrent and plots on the graph.
        &#34;&#34;&#34;
        # If this function is called without a specified sim, it gets the selected one
        # from the interface combobox
        if sim is None:
            try:  # Gets the current selected simulation
                sim = self.sim_list[self.simulation_cbox.currentIndex()]
            except:
                print(&#34;There is no simulation to choose from, create one first.&#34;)
                return

        # Reads the value of dx from the interface
        if self.adv_nm_layers_chkbx.checkState():
            # If user wants nanometers, use value as is
            dx = self.sim_dx_nm_spb.value()
            dx_unit = &#34;nm&#34;
        else:  # else, calculate dx as a multiple of monolayer = latpar/2
            dx = self.sim_dx_ml_spb.value()
            dx_unit = &#34;ml&#34;

        # Obtaining the target range of energies and converting to eV
        E0 = self.pc_E0_spb.value() * 1.0e-3
        Ef = self.pc_Ef_spb.value() * 1.0e-3
        dE = self.pc_dE_spb.value() * 1.0e-3

        sim.RunPhotocurrent(dx, E0, Ef, dE)

        self.PlotPhotocurrent(sim)
        self.SavePhotocurrentOutput(sim)

    # Simulation instance functions
    def CreateSimulation(self, title, materials):
        &#34;&#34;&#34;
        Function that creates a new simulation with the relevant information
        &#34;&#34;&#34;
        # Creating the arrays necessary to the simulation
        array_data = dict()
        array_data[&#34;estrutura&#34;] = np.array([], dtype=np.float64)
        array_data[&#34;massa_eff_const&#34;] = np.array([], dtype=np.float64)
        array_data[&#34;pot&#34;] = np.array([], dtype=np.float64)
        array_data[&#34;E_nonparab&#34;] = np.array([], dtype=np.float64)
        # Loads the available materias from the file
        self.mat = configparser.ConfigParser()
        self.mat.read(os.path.join(self.base_path, &#34;materials.data&#34;))
        # Defining material properties from the materials.data file
        material_data = dict()
        material_data[&#34;latpar&#34;] = self.mat[materials].getfloat(&#34;latpar&#34;)
        material_data[&#34;barrier&#34;] = self.mat[materials][&#34;barrier&#34;]
        material_data[&#34;m_eff_ct_barrier&#34;] = self.mat[materials].getfloat(
            &#34;m_eff_ct_barrier&#34;
        )
        material_data[&#34;e_nonparab_barrier&#34;] = self.mat[materials].getfloat(
            &#34;e_nonparab_barrier&#34;
        )
        material_data[&#34;pot_barrier&#34;] = self.mat[materials].getfloat(&#34;pot_barrier&#34;)
        material_data[&#34;well&#34;] = self.mat[materials][&#34;well&#34;]
        material_data[&#34;m_eff_ct_well&#34;] = self.mat[materials].getfloat(&#34;m_eff_ct_well&#34;)
        material_data[&#34;pot_well&#34;] = self.mat[materials].getfloat(&#34;pot_well&#34;)
        material_data[&#34;e_nonparab_well&#34;] = self.mat[materials].getfloat(
            &#34;e_nonparab_well&#34;
        )

        # Creates the simulation and puts it into a list of simulations
        self.sim_list.append(simdata.SimData(title, array_data, material_data))
        self.current_number += 1
        self.new_sim_window.close()
        self.CreatedNewSimulation()

    def DeleteSimulation(self):
        &#34;&#34;&#34;
        Deletes the simulation selected in the combobox.
        &#34;&#34;&#34;
        # Gets the index of the selected simulation
        current_index = self.simulation_cbox.currentIndex()
        list_len = len(self.sim_list)

        # Removes it from the simulations list, if not empty
        if list_len == 0:
            return
        self.sim_list.pop(current_index)

        # if it was the last item in the combobox, select the previous
        if current_index == list_len - 1:
            self.simulation_cbox.setCurrentIndex(current_index - 1)
        # else if just selects the next item
        else:
            self.simulation_cbox.setCurrentIndex(current_index)

        # Calls the function that updates the interface with the simulation selected from the
        # combobox
        # Updates the combobox to reflect the change made to the simulation list
        self.UpdateInterface()
        self.UpdateSimList()
        self.UpdateLayerCount()
        # self.ChangedSimulation()

    def RenameSimulation(self):
        # Gets the current selected simulation
        try:
            sim = self.sim_list[self.simulation_cbox.currentIndex()]
        except:
            print(&#34;There is no simulation to choose from, create one first.&#34;)
            return
        # Creates a new window pasing the selected simulation
        self.rename_window = RenameSimWindow(sim)
        # Shows the window
        self.rename_window.show()
        # Connects the signal to the function used to close the window
        self.rename_window.signal_renamed.connect(self.CloseRenameWindow)

    def CopySimulation(self):
        &#34;&#34;&#34;
        Copies the current simulation creating a new instance with the same attributes and opens the
        title window so that the user can change the title.
        &#34;&#34;&#34;
        # Gets the current selected simulation
        try:
            current_sim = self.sim_list[self.simulation_cbox.currentIndex()]
        except:
            print(&#34;There is no simulation to choose from, create one first.&#34;)
            return

        # Copies the current simulation and adds it to the list
        new_sim = deepcopy(current_sim)
        self.sim_list.append(new_sim)

        # Creates a new window
        self.rename_window = RenameSimWindow(new_sim)
        # Shows the window
        self.rename_window.show()
        # Connects the signal to the function used to close the window
        # This window will be closed by another function, which is called when the user
        # confirms the name of the new simulation. This is done by a signal emitted from
        # the TitleWindow.
        self.rename_window.signal_renamed.connect(self.CloseRenameWindow)

    # Functions related to other windows ###############################################
    def CloseRenameWindow(self):
        &#34;&#34;&#34;
        Closes the window that was opened to change the simulation name.
        &#34;&#34;&#34;
        self.UpdateSimList()
        self.rename_window.close()

    def OpenNewSimWindow(self):
        &#34;&#34;&#34;
        Creates and opens the window that will create the title for the new simulation.
        &#34;&#34;&#34;
        self.new_sim_window = NewSimWindow(self.current_number)
        # Shows the window
        self.new_sim_window.show()
        # Connects the signal to the function used to close the window
        self.new_sim_window.signal_updated_current_number.connect(
            self.UpdateCurrentNumber
        )
        # This window will be closed by another function, which is called when the user
        # confirms the name of the new simulation. This is done by a signal emitted from
        # the TitleWindow.
        self.new_sim_window.signal_new_title.connect(self.CreateSimulation)

    def UpdateCurrentNumber(self, cnum):
        &#34;&#34;&#34;
        Updates the current number, in order to keep track of how many simulations were run.
        &#34;&#34;&#34;
        self.current_number = int(cnum)

    def Sobre(self):
        &#34;&#34;&#34;
        Opens the &#34;About&#34; window
        &#34;&#34;&#34;
        # chamando a nova classe SobreWindow que cria uma nova janela
        # se nao colocar o self, garbage collection will remove that object as soon as setupUi
        # method finishes.
        self.Sobre = SobreWindow()
        # mostrando na tela a classe criada para a segunda janela
        self.Sobre.show()

    # Legacy functions #################################################################
    def Campo(self):
        &#34;&#34;&#34;
        Função que aplica o campo elétrico à estrutura no momento que o usuário aperta o botão
        apply.
        &#34;&#34;&#34;
        l = self.sim.self.sim.x_graf
        # trazendo o grafico para o centro da estrutura e colocando em nm
        l = l - l[-1] / 2  # / 1E-9
        self.sim.v_graf = (
            self.sim.v_graf - self.sim_Efield_spb.value() * 1.0e-4 * l
        )  # 1E5 * NM
        self.sim.e_field = self.sim.e_field + self.sim_Efield_spb.value()
        self.label_campo.setText(str(self.sim.e_field) + &#34; kV/cm&#34;)
        # So altero o vetor posicao ao clicar a primeira vez (quando x0 = 0). Depois disso, o x ja
        # esta definido
        if self.sim.x0 == 0:
            self.sim.x0 = self.sim.x0 - np.sum(self.sim.estrutura) / 2
            # este valor vai ser usado no calculo quando usarmos a funcao run.

        v = self.sim.v_graf
        self.sim.self.sim.x_graf = l

        self.UpdateSimGraph()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="e-mulate.MainWindow.Campo"><code class="name flex">
<span>def <span class="ident">Campo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Função que aplica o campo elétrico à estrutura no momento que o usuário aperta o botão
apply.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Campo(self):
    &#34;&#34;&#34;
    Função que aplica o campo elétrico à estrutura no momento que o usuário aperta o botão
    apply.
    &#34;&#34;&#34;
    l = self.sim.self.sim.x_graf
    # trazendo o grafico para o centro da estrutura e colocando em nm
    l = l - l[-1] / 2  # / 1E-9
    self.sim.v_graf = (
        self.sim.v_graf - self.sim_Efield_spb.value() * 1.0e-4 * l
    )  # 1E5 * NM
    self.sim.e_field = self.sim.e_field + self.sim_Efield_spb.value()
    self.label_campo.setText(str(self.sim.e_field) + &#34; kV/cm&#34;)
    # So altero o vetor posicao ao clicar a primeira vez (quando x0 = 0). Depois disso, o x ja
    # esta definido
    if self.sim.x0 == 0:
        self.sim.x0 = self.sim.x0 - np.sum(self.sim.estrutura) / 2
        # este valor vai ser usado no calculo quando usarmos a funcao run.

    v = self.sim.v_graf
    self.sim.self.sim.x_graf = l

    self.UpdateSimGraph()</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.ChooseOutputFolder"><code class="name flex">
<span>def <span class="ident">ChooseOutputFolder</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prompts the user to choose the simulation data output folder. Inside this folder, there will
be a folder with the simulation title.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ChooseOutputFolder(self):
    &#34;&#34;&#34;
    Prompts the user to choose the simulation data output folder. Inside this folder, there will
    be a folder with the simulation title.
    &#34;&#34;&#34;
    folder = QFileDialog.getExistingDirectory()
    if (
        folder
    ):  # If the output folder was properly selects, add the os separator to it
        os.path.join(folder, &#34;&#34;)  # OS independent separator
    self.output_folder_line.setText(folder)

    sim = self.sim_list[self.simulation_cbox.currentIndex()]
    sim.output_folder = self.output_folder_line.text()</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.ClearAbsPlot"><code class="name flex">
<span>def <span class="ident">ClearAbsPlot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the absorption plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ClearAbsPlot(self):
    &#34;&#34;&#34;
    Clears the absorption plot.
    &#34;&#34;&#34;
    self.abs_fig.clf()
    self.abs_fig.tight_layout()
    self.abs_subplot = self.abs_fig.add_subplot(111)
    self.abs_canvas.draw()</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.ClearDataTable"><code class="name flex">
<span>def <span class="ident">ClearDataTable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ClearDataTable(self):
    self.data_table.setRowCount(0)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.ClearMaterialData"><code class="name flex">
<span>def <span class="ident">ClearMaterialData</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the information about the materials from the Structure Tab. This
function is called when there is no simulation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ClearMaterialData(self):
    &#34;&#34;&#34;
    Removes the information about the materials from the Structure Tab. This
    function is called when there is no simulation.
    &#34;&#34;&#34;
    self.lbl_lattice_parameter_val.setText(&#34;&#34;)
    self.lbl_barrier_material_val.setText(&#34;&#34;)
    self.lbl_barrier_effective_mass_val.setText(&#34;&#34;)
    self.lbl_barrier_electronic_potential_val.setText(&#34;&#34;)
    self.lbl_barrier_non_parabolicity_val.setText(&#34;&#34;)
    self.lbl_well_material_val.setText(&#34;&#34;)
    self.lbl_well_effective_mass_val.setText(&#34;&#34;)
    self.lbl_well_electronic_potential_val.setText(&#34;&#34;)
    self.lbl_well_non_parabolicity_val.setText(&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.ClearPhotocurrentPlot"><code class="name flex">
<span>def <span class="ident">ClearPhotocurrentPlot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the photocurrent plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ClearPhotocurrentPlot(self):
    &#34;&#34;&#34;
    Clears the photocurrent plot.
    &#34;&#34;&#34;
    self.pc_fig.clf()
    self.pc_fig.tight_layout()
    self.pc_subplot = self.pc_fig.add_subplot(111)
    self.pc_canvas.draw()</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.ClearSimPlot"><code class="name flex">
<span>def <span class="ident">ClearSimPlot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the simulation plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ClearSimPlot(self):
    &#34;&#34;&#34;
    Clears the simulation plot.
    &#34;&#34;&#34;
    self.sim_fig.clf()
    self.sim_fig.tight_layout()
    self.sim_subplot = self.sim_fig.add_subplot(111)
    self.sim_canvas.draw()</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.ClearStructureTable"><code class="name flex">
<span>def <span class="ident">ClearStructureTable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ClearStructureTable(self):
    self.struct_table.setRowCount(0)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.ClearTransPlot"><code class="name flex">
<span>def <span class="ident">ClearTransPlot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the Transmission plot.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ClearTransPlot(self):
    &#34;&#34;&#34;
    Clears the Transmission plot.
    &#34;&#34;&#34;
    self.tra_fig.clf()
    self.tra_fig.tight_layout()
    self.tra_subplot = self.tra_fig.add_subplot(111)
    self.tra_canvas.draw()</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.CloseRenameWindow"><code class="name flex">
<span>def <span class="ident">CloseRenameWindow</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Closes the window that was opened to change the simulation name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CloseRenameWindow(self):
    &#34;&#34;&#34;
    Closes the window that was opened to change the simulation name.
    &#34;&#34;&#34;
    self.UpdateSimList()
    self.rename_window.close()</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.ConnectSignals"><code class="name flex">
<span>def <span class="ident">ConnectSignals</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Connect the signals from buttons to functions.
Disables any button that should only be enabled after a new simulation is
created.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConnectSignals(self):
    &#34;&#34;&#34;
    Connect the signals from buttons to functions.
    Disables any button that should only be enabled after a new simulation is
    created.
    &#34;&#34;&#34;
    # Lower bar
    # self.new_btn.clicked.connect(self.new_sim_window.show)
    self.new_btn.clicked.connect(self.OpenNewSimWindow)
    self.save_btn.clicked.connect(self.SaveSimulation)
    self.load_btn.clicked.connect(self.LoadSimulation)
    self.delete_btn.clicked.connect(self.DeleteSimulation)
    self.output_folder_btn.clicked.connect(self.ChooseOutputFolder)
    self.simulation_cbox.currentIndexChanged.connect(self.UpdateInterface)
    self.rename_btn.clicked.connect(self.RenameSimulation)
    self.copy_btn.clicked.connect(self.CopySimulation)

    # Design tab
    self.add_well_btn.clicked.connect(lambda: self.UpdateStructure(&#34;AddWell&#34;))
    self.add_barrier_btn.clicked.connect(lambda: self.UpdateStructure(&#34;AddBarrier&#34;))
    self.replace_well_btn.clicked.connect(
        lambda: self.UpdateStructure(&#34;ReplaceWell&#34;)
    )
    self.replace_barrier_btn.clicked.connect(
        lambda: self.UpdateStructure(&#34;ReplaceBarrier&#34;)
    )
    self.insert_well_btn.clicked.connect(lambda: self.UpdateStructure(&#34;InsertWell&#34;))
    self.insert_barrier_btn.clicked.connect(
        lambda: self.UpdateStructure(&#34;InsertBarrier&#34;)
    )
    self.remove_selected_btn.clicked.connect(
        lambda: self.UpdateStructure(&#34;RemoveSelected&#34;)
    )
    self.remove_last_btn.clicked.connect(lambda: self.UpdateStructure(&#34;RemoveLast&#34;))
    self.remove_all_btn.clicked.connect(lambda: self.UpdateStructure(&#34;RemoveAll&#34;))
    self.well_ml_spb.valueChanged.connect(self.UpdateUnits)
    self.well_nm_spb.valueChanged.connect(self.UpdateUnits)
    self.barrier_ml_spb.valueChanged.connect(self.UpdateUnits)
    self.barrier_nm_spb.valueChanged.connect(self.UpdateUnits)

    # Simulation tab
    self.sim_Efield_btn.clicked.connect(self.Campo)
    # Electric field button and spinbox are disabled because they don&#39;t work
    self.sim_Efield_btn.setEnabled(False)
    self.sim_Efield_spb.setEnabled(False)
    self.sim_run_btn.clicked.connect(lambda: self.RunSimulation())
    self.sim_plot_results_btn.clicked.connect(lambda: self.PlotSimResults())
    self.sim_plot_structure_btn.clicked.connect(lambda: self.PlotStructure())
    self.sim_clear_plot_btn.clicked.connect(self.ClearSimPlot)
    self.sim_dx_ml_spb.valueChanged.connect(self.UpdateUnits)
    self.sim_dx_nm_spb.valueChanged.connect(self.UpdateUnits)
    self.sim_central_layer_spb.valueChanged.connect(lambda: self.PlotStructure())

    # Absorption tab
    self.abs_run_btn.clicked.connect(lambda: self.RunAbsorption())
    self.abs_plot_btn.clicked.connect(lambda: self.PlotAbsorption())
    self.abs_clear_plot_btn.clicked.connect(self.ClearAbsPlot)

    # Transmission tab
    self.tra_run_btn.clicked.connect(lambda: self.RunTransmission())
    self.tra_plot_btn.clicked.connect(lambda: self.PlotTransmission())
    self.tra_clear_plot_btn.clicked.connect(lambda: self.ClearTransPlot())

    # Photocurrent tab
    self.pc_run_btn.clicked.connect(lambda: self.RunPhotocurrent())
    self.pc_clear_plot_btn.clicked.connect(lambda: self.ClearPhotocurrentPlot())

    # GA tab
    # self.ga_btn.clicked.connect(self.Sobre)

    # Automation tab
    self.auto_run_btn.clicked.connect(self.RunAutomation)

    # Advanced options tab
    self.adv_nm_layers_chkbx.stateChanged.connect(self.UpdateUnits)
    self.adv_save_gui_config.clicked.connect(self.SaveGUIConfigFile)

    # Actions from menus
    # File Menu
    # self.action_new.triggered.connect(self.NewSimulation)
    self.action_new.triggered.connect(self.OpenNewSimWindow)
    self.action_load.triggered.connect(self.LoadSimulation)
    self.action_save.triggered.connect(self.SaveSimulation)
    self.action_exit.triggered.connect(exit)
    # Help Menu
    self.action_about.triggered.connect(self.Sobre)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.CopySimulation"><code class="name flex">
<span>def <span class="ident">CopySimulation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Copies the current simulation creating a new instance with the same attributes and opens the
title window so that the user can change the title.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CopySimulation(self):
    &#34;&#34;&#34;
    Copies the current simulation creating a new instance with the same attributes and opens the
    title window so that the user can change the title.
    &#34;&#34;&#34;
    # Gets the current selected simulation
    try:
        current_sim = self.sim_list[self.simulation_cbox.currentIndex()]
    except:
        print(&#34;There is no simulation to choose from, create one first.&#34;)
        return

    # Copies the current simulation and adds it to the list
    new_sim = deepcopy(current_sim)
    self.sim_list.append(new_sim)

    # Creates a new window
    self.rename_window = RenameSimWindow(new_sim)
    # Shows the window
    self.rename_window.show()
    # Connects the signal to the function used to close the window
    # This window will be closed by another function, which is called when the user
    # confirms the name of the new simulation. This is done by a signal emitted from
    # the TitleWindow.
    self.rename_window.signal_renamed.connect(self.CloseRenameWindow)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.CreateOutputFolder"><code class="name flex">
<span>def <span class="ident">CreateOutputFolder</span></span>(<span>self, sim)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the selected output folder exists or must be created</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CreateOutputFolder(self, sim):
    &#34;&#34;&#34;
    Checks whether the selected output folder exists or must be created
    &#34;&#34;&#34;
    # Defines the output folder based on the simulation title
    # output_folder = str(self.output_folder_line.text())
    output_folder = sim.output_folder
    # If the folder was not chosen, just get the file execution path
    if not output_folder:
        output_folder = os.path.dirname(os.path.abspath(__file__))
    # If the menu checkbox is checked (it is, by default) create a folder with the same name as
    # the simulation
    if self.adv_new_folder_chkbx.isChecked:
        output_folder = os.path.join(output_folder, sim.title)

    return output_folder</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.CreatePlots"><code class="name flex">
<span>def <span class="ident">CreatePlots</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initial configuration of the plots</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CreatePlots(self):
    &#34;&#34;&#34;
    Initial configuration of the plots
    &#34;&#34;&#34;
    # Simulation
    self.sim_fig = plt.figure()
    self.sim_canvas = FigureCanvas(self.sim_fig)
    self.sim_plot_layout.addWidget(self.sim_canvas)
    self.sim_nav = NavigationToolbar(self.sim_canvas, self.sim_tab)
    self.sim_plot_layout.addWidget(self.sim_nav)
    self.sim_subplot = self.sim_fig.add_subplot(111)
    self.sim_subplot.grid(True, axis=&#34;y&#34;)
    self.show()
    # Absorption
    self.abs_fig = plt.figure()
    self.abs_canvas = FigureCanvas(self.abs_fig)
    self.abs_plot_layout.addWidget(self.abs_canvas)
    self.abs_nav = NavigationToolbar(self.abs_canvas, self.abs_tab)
    self.abs_plot_layout.addWidget(self.abs_nav)
    self.abs_subplot = self.abs_fig.add_subplot(111)
    self.abs_subplot.grid(True, axis=&#34;both&#34;)
    self.show()
    # Transmission
    self.tra_fig = plt.figure()
    # self.tra_fig, self.tra_ax = plt.subplots(nrows=1, ncols=1)
    self.tra_canvas = FigureCanvas(self.tra_fig)
    self.tra_plot_layout.addWidget(self.tra_canvas)
    self.tra_nav = NavigationToolbar(self.tra_canvas, self.transmission_tab)
    self.tra_plot_layout.addWidget(self.tra_nav)
    self.tra_subplot = self.tra_fig.add_subplot(111)
    self.tra_subplot.grid(True, axis=&#34;both&#34;)
    self.show()
    # Photocurrent
    self.pc_fig = plt.figure()
    self.pc_canvas = FigureCanvas(self.pc_fig)
    self.pc_plot_layout.addWidget(self.pc_canvas)
    self.pc_nav = NavigationToolbar(self.pc_canvas, self.photocurrent_tab)
    self.pc_plot_layout.addWidget(self.pc_nav)
    self.pc_subplot = self.pc_fig.add_subplot(111)
    self.pc_subplot.grid(True, axis=&#34;both&#34;)
    self.show()
    # Genetic algorithm
    self.ga_fig = plt.figure()
    self.ga_canvas = FigureCanvas(self.ga_fig)
    self.ga_plot_layout.addWidget(self.ga_canvas)
    self.ga_nav = NavigationToolbar(self.ga_canvas, self.ga_tab)
    self.ga_plot_layout.addWidget(self.ga_nav)
    self.ga_subplot = self.ga_fig.add_subplot(111)
    self.ga_subplot.grid(True, axis=&#34;both&#34;)
    self.show()</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.CreateSimulation"><code class="name flex">
<span>def <span class="ident">CreateSimulation</span></span>(<span>self, title, materials)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that creates a new simulation with the relevant information</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CreateSimulation(self, title, materials):
    &#34;&#34;&#34;
    Function that creates a new simulation with the relevant information
    &#34;&#34;&#34;
    # Creating the arrays necessary to the simulation
    array_data = dict()
    array_data[&#34;estrutura&#34;] = np.array([], dtype=np.float64)
    array_data[&#34;massa_eff_const&#34;] = np.array([], dtype=np.float64)
    array_data[&#34;pot&#34;] = np.array([], dtype=np.float64)
    array_data[&#34;E_nonparab&#34;] = np.array([], dtype=np.float64)
    # Loads the available materias from the file
    self.mat = configparser.ConfigParser()
    self.mat.read(os.path.join(self.base_path, &#34;materials.data&#34;))
    # Defining material properties from the materials.data file
    material_data = dict()
    material_data[&#34;latpar&#34;] = self.mat[materials].getfloat(&#34;latpar&#34;)
    material_data[&#34;barrier&#34;] = self.mat[materials][&#34;barrier&#34;]
    material_data[&#34;m_eff_ct_barrier&#34;] = self.mat[materials].getfloat(
        &#34;m_eff_ct_barrier&#34;
    )
    material_data[&#34;e_nonparab_barrier&#34;] = self.mat[materials].getfloat(
        &#34;e_nonparab_barrier&#34;
    )
    material_data[&#34;pot_barrier&#34;] = self.mat[materials].getfloat(&#34;pot_barrier&#34;)
    material_data[&#34;well&#34;] = self.mat[materials][&#34;well&#34;]
    material_data[&#34;m_eff_ct_well&#34;] = self.mat[materials].getfloat(&#34;m_eff_ct_well&#34;)
    material_data[&#34;pot_well&#34;] = self.mat[materials].getfloat(&#34;pot_well&#34;)
    material_data[&#34;e_nonparab_well&#34;] = self.mat[materials].getfloat(
        &#34;e_nonparab_well&#34;
    )

    # Creates the simulation and puts it into a list of simulations
    self.sim_list.append(simdata.SimData(title, array_data, material_data))
    self.current_number += 1
    self.new_sim_window.close()
    self.CreatedNewSimulation()</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.CreatedNewSimulation"><code class="name flex">
<span>def <span class="ident">CreatedNewSimulation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Called after a new simulation is created, just to update the interface</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CreatedNewSimulation(self):
    &#34;&#34;&#34;
    Called after a new simulation is created, just to update the interface
    &#34;&#34;&#34;
    self.simulation_cbox.setCurrentIndex(len(self.sim_list) - 1)
    # Defines the output folder based on the simulation title
    sim = self.sim_list[
        -1
    ]  # The new simulation was just appended to the end of the list
    sim.output_folder = str(self.output_folder_line.text())
    self.PlotStructure()
    self.UpdateStructureTable()
    self.UpdateSimList()
    self.UpdateInterface()
    self.UpdateLayerCount()
    self.UpdateUnits()</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.DeleteSimulation"><code class="name flex">
<span>def <span class="ident">DeleteSimulation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the simulation selected in the combobox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def DeleteSimulation(self):
    &#34;&#34;&#34;
    Deletes the simulation selected in the combobox.
    &#34;&#34;&#34;
    # Gets the index of the selected simulation
    current_index = self.simulation_cbox.currentIndex()
    list_len = len(self.sim_list)

    # Removes it from the simulations list, if not empty
    if list_len == 0:
        return
    self.sim_list.pop(current_index)

    # if it was the last item in the combobox, select the previous
    if current_index == list_len - 1:
        self.simulation_cbox.setCurrentIndex(current_index - 1)
    # else if just selects the next item
    else:
        self.simulation_cbox.setCurrentIndex(current_index)

    # Calls the function that updates the interface with the simulation selected from the
    # combobox
    # Updates the combobox to reflect the change made to the simulation list
    self.UpdateInterface()
    self.UpdateSimList()
    self.UpdateLayerCount()
    # self.ChangedSimulation()</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.FillMaterialData"><code class="name flex">
<span>def <span class="ident">FillMaterialData</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Fills the structure tab with data for the selected materials.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FillMaterialData(self):
    &#34;&#34;&#34;
    Fills the structure tab with data for the selected materials.
    &#34;&#34;&#34;
    sim = self.sim_list[self.simulation_cbox.currentIndex()]
    self.lbl_lattice_parameter_val.setText(f&#34;{1E10*sim.latpar:.3f} Ang&#34;)
    self.lbl_barrier_material_val.setText(f&#34;{sim.barrier}&#34;)
    self.lbl_barrier_effective_mass_val.setText(f&#34;{sim.m_eff_ct_barrier:.3e}&#34;)
    self.lbl_barrier_electronic_potential_val.setText(
        f&#34;{1E3*sim.pot_barrier:.2f} meV&#34;
    )
    self.lbl_barrier_non_parabolicity_val.setText(f&#34;{sim.e_nonparab_barrier:.3e}&#34;)
    self.lbl_well_material_val.setText(f&#34;{sim.well}&#34;)
    self.lbl_well_effective_mass_val.setText(f&#34;{sim.m_eff_ct_well:.3e}&#34;)
    self.lbl_well_electronic_potential_val.setText(f&#34;{1E3*sim.pot_well:.2f} meV&#34;)
    self.lbl_well_non_parabolicity_val.setText(f&#34;{sim.e_nonparab_well:.3e}&#34;)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.InitializeDataTable"><code class="name flex">
<span>def <span class="ident">InitializeDataTable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes the table presenting the results</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def InitializeDataTable(self):
    &#34;&#34;&#34;
    Initializes the table presenting the results
    &#34;&#34;&#34;
    self.data_table.setColumnCount(1)
    self.data_table.setColumnWidth(0, 120)
    # self.struct_table.setColumnWidth(1, 60)
    # self.struct_table.setColumnWidth(2, 40)
    # self.struct_table.setColumnWidth(3, 40)
    self.data_table.move(0, 0)
    # Definition of the header labels
    h_lbls = [&#34;Energy (meV)&#34;]
    self.data_table.setHorizontalHeaderLabels(h_lbls)
    self.data_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
    self.data_table.setSelectionBehavior(QAbstractItemView.SelectRows)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.InitializeStructTable"><code class="name flex">
<span>def <span class="ident">InitializeStructTable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes the table presenting the structure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def InitializeStructTable(self):
    &#34;&#34;&#34;
    Initializes the table presenting the structure
    &#34;&#34;&#34;
    self.struct_table.setColumnCount(4)
    self.struct_table.setColumnWidth(0, 60)
    self.struct_table.setColumnWidth(1, 60)
    self.struct_table.setColumnWidth(2, 40)
    self.struct_table.setColumnWidth(3, 40)
    self.struct_table.move(0, 0)
    self.struct_table.setHorizontalHeaderLabels([&#34;Material&#34;, &#34;Feature&#34;, &#34;ML&#34;, &#34;nm&#34;])
    self.struct_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
    self.struct_table.setSelectionBehavior(QAbstractItemView.SelectRows)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.LoadSimulation"><code class="name flex">
<span>def <span class="ident">LoadSimulation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads structure and simulation data from a file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def LoadSimulation(self):
    &#34;&#34;&#34;
    Loads structure and simulation data from a file
    &#34;&#34;&#34;
    try:  # Returns a tuple
        file, _ = QFileDialog.getOpenFileName(
            self, &#34;Loads the structure and simulation data&#34;, self.tr(&#34;*.qwsim&#34;)
        )
        input_file = open(file, &#34;rb&#34;)
        sim = pickle.load(input_file)

        self.sim_list.append(sim)
        self.simulation_cbox.setCurrentIndex(len(self.sim_list) - 1)
        self.UpdateStructureTable()
        self.UpdateSimList()
        self.UpdateLayerCount()
        # If an structure was saved, plot it
        try:  # The try-except is to avoid errors in case sim.structure doesn&#39;t exist
            if len(sim.estrutura) &gt; 0:
                self.PlotStructure(sim)
        except:
            pass
        # If a simulation result was saved, plot it
        try:
            if sim.sim_ran:
                self.PlotSimResults(sim)
        except:
            pass
        # If an absorption result was saved, plot it
        try:
            if sim.abs_ran:
                self.PlotAbsorption(sim)
        except:
            pass
        self.UpdateInterface()

    except:
        # If an error happens upon opening the file, the function just returns False.
        print(&#34;Couldn&#39;t load the structure&#34;)
        return</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.OpenNewSimWindow"><code class="name flex">
<span>def <span class="ident">OpenNewSimWindow</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and opens the window that will create the title for the new simulation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OpenNewSimWindow(self):
    &#34;&#34;&#34;
    Creates and opens the window that will create the title for the new simulation.
    &#34;&#34;&#34;
    self.new_sim_window = NewSimWindow(self.current_number)
    # Shows the window
    self.new_sim_window.show()
    # Connects the signal to the function used to close the window
    self.new_sim_window.signal_updated_current_number.connect(
        self.UpdateCurrentNumber
    )
    # This window will be closed by another function, which is called when the user
    # confirms the name of the new simulation. This is done by a signal emitted from
    # the TitleWindow.
    self.new_sim_window.signal_new_title.connect(self.CreateSimulation)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.PlotAbsorption"><code class="name flex">
<span>def <span class="ident">PlotAbsorption</span></span>(<span>self, sim=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the results from the absorption of the selected simulation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PlotAbsorption(self, sim=None):
    &#34;&#34;&#34;
    Plots the results from the absorption of the selected simulation.
    &#34;&#34;&#34;
    # If this function is called without a specified sim, it gets the selected one
    # from the interface combobox
    if sim is None:
        try:  # Gets the current selected simulation
            sim = self.sim_list[self.simulation_cbox.currentIndex()]
        except:
            print(&#34;There is no simulation to choose from, create one first.&#34;)
            return

    self.abs_subplot.plot(sim.abs_energy_axis, sim.abs_result)
    self.abs_subplot.set_xlabel(&#34;Energy (eV)&#34;)
    self.abs_subplot.set_ylabel(&#34;Absorption (u.a.)&#34;)
    self.abs_fig.tight_layout()
    self.abs_subplot.grid(True, axis=&#34;both&#34;)
    self.abs_canvas.draw()</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.PlotPhotocurrent"><code class="name flex">
<span>def <span class="ident">PlotPhotocurrent</span></span>(<span>self, sim=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the photocurrent. The photocurrent is only calculated after simulation was
run.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PlotPhotocurrent(self, sim=None):
    &#34;&#34;&#34;
    Plots the photocurrent. The photocurrent is only calculated after simulation was
    run.
    &#34;&#34;&#34;
    # If this function is called without a specified sim, it gets the selected one
    # from the interface combobox
    if sim is None:
        try:  # Gets the current selected simulation
            sim = self.sim_list[self.simulation_cbox.currentIndex()]
        except:
            print(&#34;There is no simulation to choose from, create one first.&#34;)
            return

    self.pc_subplot.plot(sim.sim_Photocurrent[0], sim.sim_Photocurrent[1])
    self.pc_subplot.set_xlabel(&#34;Energy (eV)&#34;)
    self.pc_subplot.set_ylabel(&#34;Photocurrent (u.a.)&#34;)
    self.pc_fig.tight_layout()
    self.pc_subplot.grid(True, axis=&#34;both&#34;)
    # self.pc_subplot.set_yscale(&#34;log&#34;)
    self.pc_canvas.draw()</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.PlotSimResults"><code class="name flex">
<span>def <span class="ident">PlotSimResults</span></span>(<span>self, sim=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plost the results from ResultadoWF.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PlotSimResults(self, sim=None):
    &#34;&#34;&#34;
    Plost the results from ResultadoWF.
    &#34;&#34;&#34;
    # If this function is called without a specified sim, it gets the selected one from the
    # interface combobox
    if sim is None:
        try:  # Gets the current selected simulation
            sim = self.sim_list[self.simulation_cbox.currentIndex()]
        except:
            print(&#34;There is no simulation to choose from, create one first.&#34;)
            return

    # Gets the selected simulation
    # sim = self.sim_list[self.simulation_cbox.currentIndex()]
    self.sim_subplot.grid(True, axis=&#34;y&#34;)
    # Plots the probability density
    for result in sim.sim_ResultadoWF:
        self.sim_subplot.plot(result[0, :] / NM, result[3, :] * 1.0e3)
        # self.subplot_sim.plot(result[:, 0] / 1.0E9, result[:, 3] * 1.0E0)
    self.sim_canvas.draw()</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.PlotStructure"><code class="name flex">
<span>def <span class="ident">PlotStructure</span></span>(<span>self, sim=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that interprets the structure data and create arrays to plot the graph.
It is necessary to analyze the position and potential arrays in order to correctly plot the
structure. In the interface between two materials the position is the same, but the energy
is different. If the material is repeated, but the position is different, there is no need
to create another point.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PlotStructure(self, sim=None):
    &#34;&#34;&#34;
    Function that interprets the structure data and create arrays to plot the graph.
    It is necessary to analyze the position and potential arrays in order to correctly plot the
    structure. In the interface between two materials the position is the same, but the energy
    is different. If the material is repeated, but the position is different, there is no need
    to create another point.
    &#34;&#34;&#34;
    # If this function is called without a specified sim, it gets the selected one from the
    # interface combobox
    if sim is None:
        try:  # Gets the current selected simulation
            sim = self.sim_list[self.simulation_cbox.currentIndex()]
        except:
            print(&#34;There is no simulation to choose from, create one first.&#34;)
            return

    self.ClearSimPlot()
    if len(sim.estrutura) &lt; 1:  # Only continue if there is a structure
        return
    # Creating the x and energy arrays  just for the plot
    sim.x_graf = np.array([0])
    sim.v_graf = np.array([sim.pot[0]])

    # Going through the layers and creating the arrays iteratively
    for i, en in enumerate(sim.pot):
        if (
            en == sim.v_graf[-1]
        ):  # If this layer has the same energy as the previous one
            sim.x_graf = np.append(sim.x_graf, [sim.x_graf[-1] + sim.estrutura[i]])
            sim.v_graf = np.append(sim.v_graf, [en])
        else:
            sim.x_graf = np.append(
                sim.x_graf, [sim.x_graf[-1], sim.x_graf[-1] + sim.estrutura[i]]
            )
            sim.v_graf = np.append(sim.v_graf, [en, en])

    # Changing x and y to [nm] and [meV]
    sim.x_graf = 1.0e9 * sim.x_graf
    sim.v_graf = 1.0e3 * sim.v_graf

    # Centering the structure around 0
    # sim.x_graf = sim.x_graf - (np.max(sim.x_graf) - np.min(sim.x_graf)) / 2.0

    layers = len(sim.estrutura)
    central_layer = self.sim_central_layer_spb.value()
    &#34;&#34;&#34;
    This part of the code was used to put the 0 of the x-axis in the center of a 
    layer, but this doesn&#39;t work for Pedro&#39;s photocurrent calculations, therefore
    the 0 will be at the interfaces.
    # Creating the x-axis array - the x-axis 0 is centered in the target layer
    if central_layer &lt; 0:
        x0 = 0.0
    else:
        if (
            central_layer &gt; layers - 1
        ):  # In case the number of the layer exceeds the limit
            central_layer = layers - 1
        left_x_central = np.sum(
            sim.estrutura[0:central_layer]
        )  # Thickness of layers before
        central_thickness = sim.estrutura[
            central_layer
        ]  # Thickness of target layers
        x0 = -left_x_central - central_thickness / 2.0
    x0 = x0 / NM
    sim.x_graf = sim.x_graf + x0
    &#34;&#34;&#34;
    if central_layer &lt;= 0:
        x0 = 0.0
    else:
        # In case the number of the layer exceeds the limit
        if central_layer &gt; layers:
            central_layer = layers
        # Thickness of layers on the left side of the target interface
        x0 = -np.sum(sim.estrutura[0:central_layer])
    x0 = x0 / NM
    sim.x_graf = sim.x_graf + x0

    &#34;&#34;&#34;
    Plots the structure using arrays that were created by the UpdateStructure. Doesn&#39;t erase
    the graph, in order to allow comparison between two structures
    &#34;&#34;&#34;
    # sim = self.sim_list[self.simulation_cbox.currentIndex()]
    self.sim_subplot.plot(sim.x_graf, sim.v_graf)  # x in [nm] and y in [meV]
    self.sim_subplot.set_xlabel(&#34;Length (nm)&#34;)
    self.sim_subplot.set_ylabel(&#34;Energy (meV)&#34;)
    self.sim_subplot.set_xbound(sim.x_graf[0] - 0.2, sim.x_graf[-1] + 0.2)
    self.sim_subplot.set_ybound(np.min(sim.v_graf) - 50, np.max(sim.v_graf) + 100)
    self.sim_fig.tight_layout()
    self.sim_canvas.draw()</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.PlotTransmission"><code class="name flex">
<span>def <span class="ident">PlotTransmission</span></span>(<span>self, sim=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the transmission. The transmission is only calculated after simulation was
run.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PlotTransmission(self, sim=None):
    &#34;&#34;&#34;
    Plots the transmission. The transmission is only calculated after simulation was
    run.
    &#34;&#34;&#34;
    # If this function is called without a specified sim, it gets the selected one
    # from the interface combobox
    if sim is None:
        try:  # Gets the current selected simulation
            sim = self.sim_list[self.simulation_cbox.currentIndex()]
        except:
            print(&#34;There is no simulation to choose from, create one first.&#34;)
            return

    self.tra_subplot.plot(sim.sim_VecEnergy * 1.0e3, sim.sim_Transmission)
    self.tra_subplot.set_xlabel(&#34;Energy (eV)&#34;)
    self.tra_subplot.set_ylabel(&#34;Transmission (u.a.)&#34;)
    self.tra_fig.tight_layout()
    self.tra_subplot.grid(True, axis=&#34;both&#34;)
    # self.tra_subplot.set_yscale(&#34;log&#34;)
    self.tra_canvas.draw()</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.RenameSimulation"><code class="name flex">
<span>def <span class="ident">RenameSimulation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RenameSimulation(self):
    # Gets the current selected simulation
    try:
        sim = self.sim_list[self.simulation_cbox.currentIndex()]
    except:
        print(&#34;There is no simulation to choose from, create one first.&#34;)
        return
    # Creates a new window pasing the selected simulation
    self.rename_window = RenameSimWindow(sim)
    # Shows the window
    self.rename_window.show()
    # Connects the signal to the function used to close the window
    self.rename_window.signal_renamed.connect(self.CloseRenameWindow)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.RunAbsorption"><code class="name flex">
<span>def <span class="ident">RunAbsorption</span></span>(<span>self, sim=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the structure's absorption spectra, the dipole moment, oscilator strenght and
delta energy between the absorption peaks and the reference wavefunction (wf_0).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RunAbsorption(self, sim=None):
    &#34;&#34;&#34;
    Calculates the structure&#39;s absorption spectra, the dipole moment, oscilator strenght and
    delta energy between the absorption peaks and the reference wavefunction (wf_0).
    &#34;&#34;&#34;
    # If this function is called without a specified sim, it gets the selected one from the
    # interface combobox
    if sim is None:
        try:  # Gets the current selected simulation
            sim = self.sim_list[self.simulation_cbox.currentIndex()]
        except:
            print(&#34;There is no simulation to choose from, create one first.&#34;)
            return
    # Checks whether there are at least two wavefunctions, in order to calculate the absorption.
    if len(sim.sim_Energias) &lt; 2:
        print(&#34;Cannot calculate absorption if there are less than 2 wavefunctions.&#34;)
        return
    # Collecting the relevant data from the GUI
    wf_0_index = int(self.abs_init_wf_spb.value())
    E0 = self.abs_E0_spb.value()
    Ef = self.abs_Ef_spb.value()
    dE = self.abs_dE_spb.value()
    # Linewidth broadening of the lorentzian. From &#34;Van Hove singularities in intersubband
    # transitions in multiquantum well photodetectors&#34; doi.org/10.1016/j.infrared.2006.10.016
    broadening = self.abs_broadening_spb.value()

    # Gets the choosen simulation
    # sim = self.sim_list[self.simulation_cbox.currentIndex()]
    sim.CalcAbs(wf_0_index, E0, Ef, dE, broadening)

    # Saving the absorption output to files
    output_folder = (
        sim.output_folder
    )  # As defined when the sim was created or &#34;change folder&#34;
    # Defines the output folder based on the simulation title
    if self.adv_new_folder_chkbx.isChecked:
        output_folder = os.path.join(output_folder, sim.title)
    # Saves in a folder called &#34;Absorption&#34;
    output_folder = os.path.join(output_folder, &#34;Absorption&#34;)
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)

    try:
        data = np.column_stack(
            (sim.abs_delta_E, sim.abs_dipole, sim.abs_osc_strength)
        )
        filename = f&#34;DeltaE_DipoloEletrico_ForcadeOscilador_E{wf_0_index:01d}.txt&#34;
        np.savetxt(os.path.join(output_folder, filename), data)
    except:
        print(&#34;Could not save absorption results&#34;)

    try:
        data = np.column_stack((sim.abs_energy_axis, sim.abs_result))
        filename = f&#34;Absorcao_E{wf_0_index:01d}.txt&#34;
        np.savetxt(os.path.join(output_folder, filename), data)
    except:
        print(&#34;Could not save absorption results&#34;)

    # Plot the absorption and update the interface
    self.PlotAbsorption(sim)
    self.UpdateInterface()</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.RunAutomation"><code class="name flex">
<span>def <span class="ident">RunAutomation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an automation changing the thickness of the target layer by the values
in the range defined by the user in the GUI</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RunAutomation(self):
    &#34;&#34;&#34;
    Creates an automation changing the thickness of the target layer by the values
    in the range defined by the user in the GUI
    &#34;&#34;&#34;
    # Gets the base simulation, which will be modified by the automated steps
    base_sim = self.sim_list[self.simulation_cbox.currentIndex()]

    # Obtaining the target range of thicknesses
    th_init = self.auto_init_spb.value()
    th_step = self.auto_step_spb.value()
    th_final = self.auto_final_spb.value()
    # List of thicknesses
    th_list = np.arange(th_init, th_final + th_step, th_step, dtype=float)

    # Defining whether the thickness is in nanometers or monolayers
    if (
        self.adv_nm_layers_chkbx.checkState()
    ):  # If user wants nanometers, use value as is
        th_unit = &#34;nm&#34;
    else:  # else, calculate dx as a multiple of monolayer = latpar/2
        # Correcting the units, if the value was entered in monolayers
        th_unit = &#34;ml&#34;
        th_list = th_list * base_sim.latpar / 2

    # Gets the index of the layer that must be modified
    tgt_layer = self.auto_layer_spb.value()
    # The target layer must exist. In case the structure doesn&#39;t have the defined layer, correct
    if tgt_layer &lt; 0:
        tgt_layer = 0
    elif tgt_layer &gt; len(base_sim.estrutura) - 1:
        tgt_layer = len(base_sim.estrutura) - 1

    slist = []
    # For each thickness
    for th in th_list:
        # Creates a copy of the original simulation
        new_sim = deepcopy(base_sim)
        # Puts it into the simulations list
        self.sim_list.append(new_sim)
        # Puts it into a list just for the multiprocessing
        slist.append(new_sim)
        # Changes the title based on the title of the base simulation and the modification
        new_sim.title = base_sim.title + f&#34; {th:.3f}{th_unit}&#34;
        # Changes the thickness of the target layer
        if new_sim.feature[tgt_layer] == &#34;Well&#34;:
            new_sim.ReplaceWell(th, tgt_layer)
        else:
            new_sim.ReplaceBarrier(th, tgt_layer)
        self.RunSimulation(new_sim)

    # cores = cpu_count()
    # p = Pool(processes=cores)
    # p = Pool(processes=1)
    # p.map(self.RunASim, slist)
    # with Pool(processes=cores) as p:
    #     for i, _ in enumerate(p.imap_unordered(self.RunASim, slist)):
    #         print(i)

    self.UpdateStructureTable()
    self.UpdateSimList()</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.RunPhotocurrent"><code class="name flex">
<span>def <span class="ident">RunPhotocurrent</span></span>(<span>self, sim=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs the calculation of the Photocurrent and plots on the graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RunPhotocurrent(self, sim=None):
    &#34;&#34;&#34;
    Performs the calculation of the Photocurrent and plots on the graph.
    &#34;&#34;&#34;
    # If this function is called without a specified sim, it gets the selected one
    # from the interface combobox
    if sim is None:
        try:  # Gets the current selected simulation
            sim = self.sim_list[self.simulation_cbox.currentIndex()]
        except:
            print(&#34;There is no simulation to choose from, create one first.&#34;)
            return

    # Reads the value of dx from the interface
    if self.adv_nm_layers_chkbx.checkState():
        # If user wants nanometers, use value as is
        dx = self.sim_dx_nm_spb.value()
        dx_unit = &#34;nm&#34;
    else:  # else, calculate dx as a multiple of monolayer = latpar/2
        dx = self.sim_dx_ml_spb.value()
        dx_unit = &#34;ml&#34;

    # Obtaining the target range of energies and converting to eV
    E0 = self.pc_E0_spb.value() * 1.0e-3
    Ef = self.pc_Ef_spb.value() * 1.0e-3
    dE = self.pc_dE_spb.value() * 1.0e-3

    sim.RunPhotocurrent(dx, E0, Ef, dE)

    self.PlotPhotocurrent(sim)
    self.SavePhotocurrentOutput(sim)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.RunSimulation"><code class="name flex">
<span>def <span class="ident">RunSimulation</span></span>(<span>self, sim=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is a copy of "Run" but it takes the simulation as an argument
instead of getting the selected simulation from the combobox.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RunSimulation(self, sim=None):
    &#34;&#34;&#34;
    This function is a copy of &#34;Run&#34; but it takes the simulation as an argument
    instead of getting the selected simulation from the combobox.
    &#34;&#34;&#34;
    # If this function is called without a specified sim, it gets the selected one
    # from the interface combobox
    if sim is None:
        try:  # Gets the current selected simulation
            sim = self.sim_list[self.simulation_cbox.currentIndex()]
        except:
            print(&#34;There is no simulation to choose from, create one first.&#34;)
            return

    # Obtaining the target range of energies
    E0 = self.sim_E0_spb.value()
    Ef = self.sim_Ef_spb.value()
    dE = self.sim_dE_spb.value()

    # Reads the value of dx from the interface
    if self.adv_nm_layers_chkbx.checkState():
        # If user wants nanometers, use value as is
        dx = self.sim_dx_nm_spb.value()
        dx_unit = &#34;nm&#34;
    else:  # else, calculate dx as a multiple of monolayer = latpar/2
        dx = self.sim_dx_ml_spb.value()
        dx_unit = &#34;ml&#34;

    # From the interface, defines the interface of the wavefunction split
    split_i = self.adv_split_layer_spb.value()

    # From the structure tab, gets the index of the central layer
    central_layer = self.sim_central_layer_spb.value()

    # The method chosen by the user to perform the calculations
    # Methods avaliable:
    # 0 - &#34;Numerov - For&#34;
    # 1 - &#34;Numerov - Split&#34;
    # 2 - &#34;Numerov - Arrays&#34;
    # 3 - &#34;TMM&#34;
    # 4 - &#34;TMM - Split&#34;
    wf_method = self.adv_method_cbox.currentIndex()

    # Timing
    t_start_run = time.time()

    # Runs the calculations with information gathered from the interface and stored
    # at a &#34;sim&#34;.
    # Sim is the selected simulation, containing all relevant data
    sim.RunSim(wf_method, split_i, E0, Ef, dE, dx, dx_unit, central_layer)
    # Timing
    print(f&#34;Total time: {time.time() - t_start_run:.3f} s&#34;)

    self.SaveSimOutput(sim)
    self.PlotSimResults(sim)
    self.UpdateInterface()
    self.UpdateDataTable()
    # If the user wants, automatically calculate the absorption, transmission or
    # photocurrent after the main simulation
    if self.sim_autorun_abs_chkbx.checkState():
        self.RunAbsorption(sim)
    if self.sim_autorun_tra_chkbx.checkState():
        self.RunTransmission(sim)
    if self.sim_autorun_pc_chkbx.checkState():
        self.RunPhotocurrent(sim)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.RunTransmission"><code class="name flex">
<span>def <span class="ident">RunTransmission</span></span>(<span>self, sim=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs the calculation of the transmission and displays it on the graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RunTransmission(self, sim=None):
    &#34;&#34;&#34;
    Performs the calculation of the transmission and displays it on the graph.
    &#34;&#34;&#34;
    # If this function is called without a specified sim, it gets the selected one
    # from the interface combobox
    if sim is None:
        try:  # Gets the current selected simulation
            sim = self.sim_list[self.simulation_cbox.currentIndex()]
        except:
            print(&#34;There is no simulation to choose from, create one first.&#34;)
            return

    sim.Transmission()

    self.PlotTransmission(sim)
    self.SaveTransmissionOutput(sim)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.SaveGUIConfigFile"><code class="name flex">
<span>def <span class="ident">SaveGUIConfigFile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves all the values and settings on the interface to the "interface.cfg" file.
This is meant to be a easy way of saving the default settings, so that the user doesn't need
to change the values every time the software is opened, nor needs to manually edit the
config file.
The values must be in string format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SaveGUIConfigFile(self):
    &#34;&#34;&#34;
    Saves all the values and settings on the interface to the &#34;interface.cfg&#34; file.
    This is meant to be a easy way of saving the default settings, so that the user doesn&#39;t need
    to change the values every time the software is opened, nor needs to manually edit the
    config file.
    The values must be in string format.
    &#34;&#34;&#34;
    # Reads the configuration defaults from the &#34;interface.cfg&#34; file:
    cfg = configparser.ConfigParser()
    file = os.path.join(self.base_path, &#34;interface.cfg&#34;)
    cfg.read(file)

    # Structure tab
    # Saves only the values of nm or ml, depending on the checkbox state
    if self.adv_nm_layers_chkbx.checkState():
        cfg[&#34;stru&#34;][&#34;barrier_nm&#34;] = f&#34;{self.barrier_nm_spb.value()}&#34;
        cfg[&#34;stru&#34;][&#34;well_nm&#34;] = f&#34;{self.well_nm_spb.value()}&#34;
    else:
        cfg[&#34;stru&#34;][&#34;barrier_ml&#34;] = f&#34;{self.barrier_ml_spb.value()}&#34;
        cfg[&#34;stru&#34;][&#34;well_ml&#34;] = f&#34;{self.well_ml_spb.value()}&#34;

    # Simulation tab
    cfg[&#34;simu&#34;][&#34;E0&#34;] = f&#34;{self.sim_E0_spb.value()}&#34;
    cfg[&#34;simu&#34;][&#34;dE&#34;] = f&#34;{self.sim_dE_spb.value()}&#34;
    cfg[&#34;simu&#34;][&#34;Ef&#34;] = f&#34;{self.sim_Ef_spb.value()}&#34;
    if self.adv_nm_layers_chkbx.checkState():
        cfg[&#34;simu&#34;][&#34;dx_nm&#34;] = f&#34;{self.sim_dx_nm_spb.value()}&#34;
    else:
        cfg[&#34;simu&#34;][&#34;dx_ml&#34;] = f&#34;{self.sim_dx_ml_spb.value()}&#34;
    cfg[&#34;simu&#34;][&#34;Efield&#34;] = f&#34;{self.sim_Efield_spb.value()}&#34;
    cfg[&#34;simu&#34;][&#34;central_layer&#34;] = f&#34;{self.sim_central_layer_spb.value()}&#34;
    # Checkboxes
    cfg[&#34;simu&#34;][&#34;output_all&#34;] = (
        &#34;True&#34; if self.sim_files_all_chkbx.checkState() else &#34;False&#34;
    )
    cfg[&#34;simu&#34;][&#34;output_effm&#34;] = (
        &#34;True&#34; if self.sim_files_effm_chkbx.checkState() else &#34;False&#34;
    )
    cfg[&#34;simu&#34;][&#34;output_energies&#34;] = (
        &#34;True&#34; if self.sim_files_energies_chkbx.checkState() else &#34;False&#34;
    )
    cfg[&#34;simu&#34;][&#34;output_npe&#34;] = (
        &#34;True&#34; if self.sim_files_npe_chkbx.checkState() else &#34;False&#34;
    )
    cfg[&#34;simu&#34;][&#34;output_pot&#34;] = (
        &#34;True&#34; if self.sim_files_pot_chkbx.checkState() else &#34;False&#34;
    )
    cfg[&#34;simu&#34;][&#34;output_trans&#34;] = (
        &#34;True&#34; if self.sim_files_trans_chkbx.checkState() else &#34;False&#34;
    )
    cfg[&#34;simu&#34;][&#34;output_wf&#34;] = (
        &#34;True&#34; if self.sim_files_wf_chkbx.checkState() else &#34;False&#34;
    )
    cfg[&#34;simu&#34;][&#34;output_x&#34;] = (
        &#34;True&#34; if self.sim_files_x_chkbx.checkState() else &#34;False&#34;
    )

    # Absorption tab
    cfg[&#34;abso&#34;][&#34;initial_WF&#34;] = f&#34;{self.abs_init_wf_spb.value()}&#34;
    cfg[&#34;abso&#34;][&#34;lorz_broad&#34;] = f&#34;{self.abs_broadening_spb.value()}&#34;
    cfg[&#34;abso&#34;][&#34;E0&#34;] = f&#34;{self.abs_E0_spb.value()}&#34;
    cfg[&#34;abso&#34;][&#34;dE&#34;] = f&#34;{self.abs_dE_spb.value()}&#34;
    cfg[&#34;abso&#34;][&#34;Ef&#34;] = f&#34;{self.abs_Ef_spb.value()}&#34;

    # Transmission tab

    # Photocurrent tab
    cfg[&#34;phot&#34;][&#34;E0&#34;] = f&#34;{self.pc_E0_spb.value()}&#34;
    cfg[&#34;phot&#34;][&#34;dE&#34;] = f&#34;{self.pc_dE_spb.value()}&#34;
    cfg[&#34;phot&#34;][&#34;Ef&#34;] = f&#34;{self.pc_Ef_spb.value()}&#34;

    # Genetic Algorithm tab
    cfg[&#34;gene&#34;][&#34;iterations&#34;] = f&#34;{self.ga_iter_spb.value():d}&#34;
    cfg[&#34;gene&#34;][&#34;population&#34;] = f&#34;{self.ga_pop_spb.value():d}&#34;
    cfg[&#34;gene&#34;][&#34;target_E&#34;] = f&#34;{self.ga_tgt_en_spb.value()}&#34;
    cfg[&#34;gene&#34;][&#34;target_E_margin&#34;] = f&#34;{self.ga_tgt_en_margin_spb.value()}&#34;
    cfg[&#34;gene&#34;][&#34;goal&#34;] = f&#34;{self.ga_goal_cbox.currentIndex():d}&#34;

    # Automation tab
    cfg[&#34;auto&#34;][&#34;target_layer&#34;] = f&#34;{self.auto_layer_spb.value():d}&#34;
    cfg[&#34;auto&#34;][&#34;thickness_initial&#34;] = f&#34;{self.auto_init_spb.value()}&#34;
    cfg[&#34;auto&#34;][&#34;thickness_step&#34;] = f&#34;{self.auto_step_spb.value()}&#34;
    cfg[&#34;auto&#34;][&#34;thickness_final&#34;] = f&#34;{self.auto_final_spb.value()}&#34;

    # Data tab

    # Advanced tab
    cfg[&#34;adva&#34;][&#34;create_new_folder&#34;] = (
        &#34;True&#34; if self.adv_new_folder_chkbx.checkState() else &#34;False&#34;
    )
    cfg[&#34;adva&#34;][&#34;use_nanometers&#34;] = (
        &#34;True&#34; if self.adv_nm_layers_chkbx.checkState() else &#34;False&#34;
    )
    cfg[&#34;adva&#34;][&#34;autorun_abs&#34;] = (
        &#34;True&#34; if self.adv_autorun_abs_chkbx.checkState() else &#34;False&#34;
    )
    cfg[&#34;adva&#34;][&#34;autorun_abs_initial_WF&#34;] = f&#34;{self.adv_wf0_spb.value()}&#34;
    cfg[&#34;adva&#34;][&#34;autorun_trans&#34;] = (
        &#34;True&#34; if self.adv_autorun_trans_chkbx.checkState() else &#34;False&#34;
    )
    cfg[&#34;adva&#34;][&#34;interface_to_split&#34;] = f&#34;{self.adv_split_layer_spb.value()}&#34;
    cfg[&#34;adva&#34;][&#34;method&#34;] = f&#34;{self.adv_method_cbox.currentIndex()}&#34;

    # Saves the configuration file
    with open(file, &#34;w&#34;) as configfile:
        cfg.write(configfile)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.SavePhotocurrentOutput"><code class="name flex">
<span>def <span class="ident">SavePhotocurrentOutput</span></span>(<span>self, sim)</span>
</code></dt>
<dd>
<div class="desc"><p>Based on the interface's checkboxes, saves the Transmission output</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SavePhotocurrentOutput(self, sim):
    &#34;&#34;&#34;
    Based on the interface&#39;s checkboxes, saves the Transmission output
    &#34;&#34;&#34;
    output_folder = self.CreateOutputFolder(sim)

    # After the end of the calculations, save the result in text files if desired
    if self.sim_files_all_chkbx.isChecked() or self.sim_files_pc_chkbox.isChecked():
        data_folder = os.path.join(output_folder, &#34;Data&#34;)

        # if the folder to save the data doesn&#39;t exist, create it
        if not os.path.exists(data_folder):
            os.makedirs(data_folder)

        output = sim.sim_Photocurrent
        output_file = os.path.join(data_folder, &#34;Photocurrent Spectrum.txt&#34;)
        np.savetxt(output_file, output)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.SaveSimOutput"><code class="name flex">
<span>def <span class="ident">SaveSimOutput</span></span>(<span>self, sim)</span>
</code></dt>
<dd>
<div class="desc"><p>Based on the interface's checkboxes, saves the simulation output</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SaveSimOutput(self, sim):
    &#34;&#34;&#34;
    Based on the interface&#39;s checkboxes, saves the simulation output
    &#34;&#34;&#34;
    output_folder = self.CreateOutputFolder(sim)

    # To avoid repetition of the &#34;all checkbox&#34;
    save_all = self.sim_files_all_chkbx.isChecked()

    # After the end of the calculations, save the result in text files if desired
    if (
        save_all
        or self.sim_files_effm_chkbx.isChecked()
        or self.sim_files_energies_chkbx.isChecked()
        or self.sim_files_npe_chkbx.isChecked()
        or self.sim_files_pot_chkbx.isChecked()
        or self.sim_files_wf_chkbx.isChecked()
        or self.sim_files_x_chkbx.isChecked()
    ):
        data_folder = os.path.join(output_folder, &#34;Data&#34;)

        # if the folder to save the data doesn&#39;t exist, create it
        if not os.path.exists(data_folder):
            os.makedirs(data_folder)

    if save_all or self.sim_files_x_chkbx.isChecked():
        np.savetxt(os.path.join(data_folder, &#34;X Axis.txt&#34;), sim.sim_x, newline=&#34;\n&#34;)

    if save_all or self.sim_files_pot_chkbx.isChecked():
        np.savetxt(
            os.path.join(data_folder, &#34;Electrical Potential.txt&#34;),
            sim.sim_pot,
            newline=&#34;\n&#34;,
        )

    if save_all or self.sim_files_effm_chkbx.isChecked():
        np.savetxt(
            os.path.join(data_folder, &#34;Effective Mass.txt&#34;),
            sim.sim_effm_cte,
            newline=&#34;\n&#34;,
        )

    if save_all or self.sim_files_npe_chkbx.isChecked():
        np.savetxt(
            os.path.join(data_folder, &#34;Non-Parabolicity.txt&#34;),
            sim.sim_npe,
            newline=&#34;\n&#34;,
        )

    if save_all or self.sim_files_energies_chkbx.isChecked():
        np.savetxt(os.path.join(data_folder, &#34;Autoenergias.txt&#34;), sim.sim_Energias)

    if save_all or self.sim_files_wf_chkbx.isChecked():
        PastaWave = os.path.join(data_folder, &#34;Wave Functions&#34;)
        if not os.path.exists(PastaWave):
            os.makedirs(PastaWave)
        for a in range(len(sim.sim_Energias)):
            fname = f&#34;WF_E{a}_{sim.sim_Energias[a]:02.6f}.txt&#34;
            # The transposed is print, so that the WF is in a column, not row
            np.savetxt(os.path.join(PastaWave, fname), sim.sim_ResultadoWF[a].T)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.SaveSimulation"><code class="name flex">
<span>def <span class="ident">SaveSimulation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the structure, simulation and absorption parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SaveSimulation(self):
    &#34;&#34;&#34;
    Saves the structure, simulation and absorption parameters.
    &#34;&#34;&#34;
    sim = self.sim_list[self.simulation_cbox.currentIndex()]
    try:
        save_dir = os.path.join(sim.output_folder, f&#34;{sim.title}.qwsim&#34;)
        # print(f&#39;save_dir: {save_dir}&#39;)
        file, _ = QFileDialog.getSaveFileName(
            self,
            caption=&#34;Save structure and simulation parameters&#34;,
            directory=save_dir,
            filter=self.tr(&#34;*.qwsim&#34;),
        )

        output_file = open(file, &#34;wb&#34;)
        pickle.dump(sim, output_file)
        output_file.close()
    except:
        print(&#34;Couldn&#39;t save the structure&#34;)
        # If the user doesn&#39;t choose a filename, closing the interface, do nothing
        return</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.SaveTransmissionOutput"><code class="name flex">
<span>def <span class="ident">SaveTransmissionOutput</span></span>(<span>self, sim)</span>
</code></dt>
<dd>
<div class="desc"><p>Based on the interface's checkboxes, saves the Transmission output</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SaveTransmissionOutput(self, sim):
    &#34;&#34;&#34;
    Based on the interface&#39;s checkboxes, saves the Transmission output
    &#34;&#34;&#34;
    output_folder = self.CreateOutputFolder(sim)

    # After the end of the calculations, save the result in text files if desired
    if (
        self.sim_files_all_chkbx.isChecked()
        or self.sim_files_trans_chkbx.isChecked()
    ):
        data_folder = os.path.join(output_folder, &#34;Data&#34;)

        # if the folder to save the data doesn&#39;t exist, create it
        if not os.path.exists(data_folder):
            os.makedirs(data_folder)

        output = np.column_stack((sim.sim_VecEnergy, sim.sim_Transmission))
        output_file = os.path.join(data_folder, &#34;Transmission Spectrum.txt&#34;)
        np.savetxt(output_file, output)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.Sobre"><code class="name flex">
<span>def <span class="ident">Sobre</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Opens the "About" window</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Sobre(self):
    &#34;&#34;&#34;
    Opens the &#34;About&#34; window
    &#34;&#34;&#34;
    # chamando a nova classe SobreWindow que cria uma nova janela
    # se nao colocar o self, garbage collection will remove that object as soon as setupUi
    # method finishes.
    self.Sobre = SobreWindow()
    # mostrando na tela a classe criada para a segunda janela
    self.Sobre.show()</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.UpdateCurrentNumber"><code class="name flex">
<span>def <span class="ident">UpdateCurrentNumber</span></span>(<span>self, cnum)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the current number, in order to keep track of how many simulations were run.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def UpdateCurrentNumber(self, cnum):
    &#34;&#34;&#34;
    Updates the current number, in order to keep track of how many simulations were run.
    &#34;&#34;&#34;
    self.current_number = int(cnum)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.UpdateDataTable"><code class="name flex">
<span>def <span class="ident">UpdateDataTable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that updates the table at the data tab. The table is erased every time and
rewritten with data from the latest simulation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def UpdateDataTable(self):
    &#34;&#34;&#34;
    Function that updates the table at the data tab. The table is erased every time and
    rewritten with data from the latest simulation
    &#34;&#34;&#34;
    self.ClearDataTable()
    # Gets the current selected simulation
    sim = self.sim_list[self.simulation_cbox.currentIndex()]

    self.data_table.setRowCount(len(sim.sim_Energias))
    for i, energia in enumerate(sim.sim_Energias):

        col0 = QTableWidgetItem(f&#34;{energia * 1000:.3f} meV&#34;)  # Creates the item
        col0.setTextAlignment(0x0084)  # Align h center, v baseline
        # col1 = QTableWidgetItem(sim.feature[i])
        # col1.setTextAlignment(0x0084)  # Align h center, v baseline
        # col2 = QTableWidgetItem(f&#34;{sim.estrutura[i] / ( sim.latpar / 2):.0f}&#34;)
        # col2.setTextAlignment(0x0082)  # Align h right, v baseline
        # col3 = QTableWidgetItem(f&#34;{sim.estrutura[i] / NM:.3f}&#34;)
        # col3.setTextAlignment(0x0082)  # Align h right, v baseline
        self.data_table.setItem(i, 0, col0)
        # self.struct_table.setItem(i, 1, col1)
        # self.struct_table.setItem(i, 2, col2)
        # self.struct_table.setItem(i, 3, col3)
        # Adjusts the line heigth
        self.data_table.setRowHeight(i, 18)
        # Corrects the line index (without this correction, it starts from 1, instead of 0)
        self.data_table.setVerticalHeaderItem(i, QTableWidgetItem(f&#34;{i}&#34;))
    # Adjusts the column width
    self.data_table.setColumnWidth(0, 120)
    # self.struct_table.setColumnWidth(1, 60)
    # self.struct_table.setColumnWidth(2, 40)
    # self.struct_table.setColumnWidth(3, 40)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.UpdateInterface"><code class="name flex">
<span>def <span class="ident">UpdateInterface</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the buttons, list of simulations available on the simulations combobox.
This simulation is called almost everytime after user interaction.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def UpdateInterface(self):
    &#34;&#34;&#34;
    Updates the buttons, list of simulations available on the simulations combobox.
    This simulation is called almost everytime after user interaction.
    &#34;&#34;&#34;
    # Check whether there are simulations
    # The selected simulation defines whether some options on the interface are available
    # If there are no simulations, disable most buttons, except &#34;load&#34; and &#34;new&#34;
    if len(self.sim_list) == 0:
        # Lower bar
        self.save_btn.setEnabled(False)
        self.delete_btn.setEnabled(False)
        self.copy_btn.setEnabled(False)
        self.rename_btn.setEnabled(False)
        self.output_folder_btn.setEnabled(False)
        # Structure tab
        self.add_well_btn.setEnabled(False)
        self.add_barrier_btn.setEnabled(False)
        self.replace_well_btn.setEnabled(False)
        self.replace_barrier_btn.setEnabled(False)
        self.insert_well_btn.setEnabled(False)
        self.insert_barrier_btn.setEnabled(False)
        self.remove_selected_btn.setEnabled(False)
        self.remove_last_btn.setEnabled(False)
        self.remove_all_btn.setEnabled(False)
        # Layer thickness spinboxes
        self.barrier_ml_spb.setEnabled(False)
        self.well_ml_spb.setEnabled(False)
        self.barrier_nm_spb.setEnabled(False)
        self.well_nm_spb.setEnabled(False)
        # Simulation tab
        self.sim_Efield_btn.setEnabled(False)
        self.sim_run_btn.setEnabled(False)
        self.sim_plot_results_btn.setEnabled(False)
        self.sim_plot_structure_btn.setEnabled(False)
        # Absorption tab
        self.abs_run_btn.setEnabled(False)
        self.abs_plot_btn.setEnabled(False)
        # Transmission tab
        self.tra_plot_btn.setEnabled(False)
        # Photocurrent tab
        self.pc_run_btn.setEnabled(False)
        # Genetic algorithm tab
        self.ga_run_btn.setEnabled(False)
        # Automation tab
        self.auto_run_btn.setEnabled(False)

        self.ClearStructureTable()
        self.ClearSimPlot()
        self.ClearAbsPlot()
        self.ClearMaterialData()

    else:
        # current simulation
        sim = self.sim_list[self.simulation_cbox.currentIndex()]
        # If there are available simulations, some buttons must to be enabled
        # Lower bar
        self.save_btn.setEnabled(True)
        self.delete_btn.setEnabled(True)
        self.copy_btn.setEnabled(True)
        self.rename_btn.setEnabled(True)
        self.output_folder_btn.setEnabled(True)
        # Structure tab
        self.add_well_btn.setEnabled(True)
        self.add_barrier_btn.setEnabled(True)
        self.insert_well_btn.setEnabled(True)
        self.insert_barrier_btn.setEnabled(True)
        # Layer thickness spinboxes
        if self.adv_nm_layers_chkbx.checkState():
            self.barrier_nm_spb.setEnabled(True)
            self.well_nm_spb.setEnabled(True)
        else:
            self.barrier_ml_spb.setEnabled(True)
            self.well_ml_spb.setEnabled(True)

        if (
            len(sim.estrutura) &gt; 0
        ):  # If the structure is has layers, a simulation may be run
            # Simulation tab
            self.sim_run_btn.setEnabled(True)
            self.sim_plot_structure_btn.setEnabled(True)
            # Structure tab
            self.replace_well_btn.setEnabled(True)
            self.replace_barrier_btn.setEnabled(True)
            self.remove_selected_btn.setEnabled(True)
            self.remove_last_btn.setEnabled(True)
            self.remove_all_btn.setEnabled(True)
            # Genetic algorithm tab
            self.ga_run_btn.setEnabled(True)
            # Automation tab
            self.auto_run_btn.setEnabled(True)

            if sim.sim_ran is False:  # If the simulation has not yet been executed
                # Simulation tab
                self.sim_plot_results_btn.setEnabled(False)
                # Absorption tab
                self.abs_run_btn.setEnabled(False)
                # Transmission tab
                self.tra_plot_btn.setEnabled(False)
                # Photocurrent tab
                self.pc_run_btn.setEnabled(False)
            else:
                # Simulation tab
                self.sim_plot_results_btn.setEnabled(True)
                # Absorption tab
                self.abs_run_btn.setEnabled(True)
                # Transmission tab
                self.tra_plot_btn.setEnabled(True)
                # Photocurrent tab
                self.pc_run_btn.setEnabled(True)

            if (
                sim.abs_ran is False
            ):  # If the absorption has not yet been calculated
                self.abs_plot_btn.setEnabled(False)
            else:
                self.abs_plot_btn.setEnabled(True)
        else:
            # Simulation tab
            self.sim_run_btn.setEnabled(False)
            # Structure tab
            self.replace_well_btn.setEnabled(False)
            self.replace_barrier_btn.setEnabled(False)
            self.remove_selected_btn.setEnabled(False)
            self.remove_last_btn.setEnabled(False)
            self.remove_all_btn.setEnabled(False)
            # Simulation tab
            self.sim_Efield_btn.setEnabled(False)
            self.sim_plot_results_btn.setEnabled(False)
            self.sim_plot_structure_btn.setEnabled(False)
            # Absorption tab
            self.abs_run_btn.setEnabled(False)
            # Genetic algorithm tab
            self.ga_run_btn.setEnabled(False)
            # Automation tab
            self.auto_run_btn.setEnabled(False)
        self.UpdateStructureTable()
        self.FillMaterialData()</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.UpdateLayerCount"><code class="name flex">
<span>def <span class="ident">UpdateLayerCount</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the number of layers and updates the Spinbox on the advanced tab</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def UpdateLayerCount(self):
    &#34;&#34;&#34;
    Calculates the number of layers and updates the Spinbox on the advanced tab
    &#34;&#34;&#34;

    try:  # If there is a simulation and this simulation has at least one layer
        sim = self.sim_list[self.simulation_cbox.currentIndex()]
        layers = len(sim.estrutura)
        self.adv_total_layers_spb.setValue(layers)
    except:  # If there is no simulation or it doesn&#39;t have any layers yet
        self.adv_total_layers_spb.setValue(0)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.UpdateSimList"><code class="name flex">
<span>def <span class="ident">UpdateSimList</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If simulations are added, deleted or loaded, needs to update the list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def UpdateSimList(self):
    &#34;&#34;&#34;
    If simulations are added, deleted or loaded, needs to update the list
    &#34;&#34;&#34;
    # Clears the simulation list
    self.simulation_cbox.clear()
    # Fills the simulation combobox with every simulation from the list
    for sim in self.sim_list:
        self.simulation_cbox.addItem(sim.title)
    self.simulation_cbox.setCurrentIndex(len(self.sim_list) - 1)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.UpdateStructure"><code class="name flex">
<span>def <span class="ident">UpdateStructure</span></span>(<span>self, op)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that adds, inserts or removes layers from the surface, based on the user choice on
the GUI.
op is the operation the user wants to perform, defined in self.ConnectSignals</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def UpdateStructure(self, op):
    &#34;&#34;&#34;
    Function that adds, inserts or removes layers from the surface, based on the user choice on
    the GUI.
    op is the operation the user wants to perform, defined in self.ConnectSignals
    &#34;&#34;&#34;
    sim = self.sim_list[self.simulation_cbox.currentIndex()]

    # Adding a new well
    if op == &#34;AddWell&#34;:
        sim.AddWell(self.well_nm_spb.value())

    # Adding a new barrier
    elif op == &#34;AddBarrier&#34;:
        sim.AddBarrier(self.barrier_nm_spb.value())

    # Replacing a well
    elif op == &#34;ReplaceWell&#34;:
        index = self.struct_table.currentRow()  # Selected table line
        if index == -1:  # In case there is nothing to replace
            return
        sim.ReplaceWell(self.well_nm_spb.value(), index)

    # Replacing a barrier
    elif op == &#34;ReplaceBarrier&#34;:
        index = self.struct_table.currentRow()  # Selected table line
        if index == -1:  # In case there is nothing to replace
            return
        sim.ReplaceBarrier(self.barrier_nm_spb.value(), index)

    # Inserting a well
    elif op == &#34;InsertWell&#34;:
        index = self.struct_table.currentRow()  # Selected table line
        sim.InsertWell(self.well_nm_spb.value(), index)

    # Inserting a barrier
    elif op == &#34;InsertBarrier&#34;:
        index = self.struct_table.currentRow()  # Selected table line
        sim.InsertBarrier(self.barrier_nm_spb.value(), index)

    elif op == &#34;RemoveSelected&#34;:
        index = self.struct_table.currentRow()  # Linha da tabela selecionada
        if len(sim.estrutura) &gt; 1:  # If there is a structure, delete the last item
            sim.RemoveSelected(index)
        else:
            op = &#34;RemoveAll&#34;  # Just to avoid repeating 5 lines of code

    elif op == &#34;RemoveLast&#34;:
        if len(sim.estrutura) &gt; 1:  # If there is a structure, delete the last item
            sim.RemoveSelected(-1)
        else:
            op = &#34;RemoveAll&#34;  # Just to avoid repeating 5 lines of code

    # This is not &#34;elif&#34; just so that the &#34;else&#34; from RemoveSelected and RemoveLast work
    if op == &#34;RemoveAll&#34;:
        sim.RemoveAll()

    # Since the structure was modified, define this simulation as not ran
    sim.sim_ran = False
    sim.abs_ran = False

    # Updates table, graph and buttons
    self.UpdateStructureTable()
    self.PlotStructure(sim)
    self.UpdateInterface()
    self.UpdateLayerCount()</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.UpdateStructureTable"><code class="name flex">
<span>def <span class="ident">UpdateStructureTable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that updates the table at the structure tab. The table is erased every time and
rewrites it all again usig information from sim.material and sim.estrutura.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def UpdateStructureTable(self):
    &#34;&#34;&#34;
    Function that updates the table at the structure tab. The table is erased every time and
    rewrites it all again usig information from sim.material and sim.estrutura.
    &#34;&#34;&#34;
    sim = self.sim_list[self.simulation_cbox.currentIndex()]
    self.struct_table.setRowCount(len(sim.material))
    for i, material in enumerate(sim.material):
        col0 = QTableWidgetItem(material)  # Creates the item
        col0.setTextAlignment(0x0084)  # Align h center, v baseline
        col1 = QTableWidgetItem(sim.feature[i])
        col1.setTextAlignment(0x0084)  # Align h center, v baseline
        col2 = QTableWidgetItem(f&#34;{sim.estrutura[i] / ( sim.latpar / 2):.0f}&#34;)
        col2.setTextAlignment(0x0082)  # Align h right, v baseline
        col3 = QTableWidgetItem(f&#34;{sim.estrutura[i] / NM:.3f}&#34;)
        col3.setTextAlignment(0x0082)  # Align h right, v baseline
        self.struct_table.setItem(i, 0, col0)
        self.struct_table.setItem(i, 1, col1)
        self.struct_table.setItem(i, 2, col2)
        self.struct_table.setItem(i, 3, col3)
        # Adjusts the line heigth
        self.struct_table.setRowHeight(i, 18)
        # Corrects the line index (without this correction, it starts from 1, instead of 0)
        self.struct_table.setVerticalHeaderItem(i, QTableWidgetItem(f&#34;{i}&#34;))
    # Adjusts the column width
    self.struct_table.setColumnWidth(0, 60)
    self.struct_table.setColumnWidth(1, 60)
    self.struct_table.setColumnWidth(2, 40)
    self.struct_table.setColumnWidth(3, 40)</code></pre>
</details>
</dd>
<dt id="e-mulate.MainWindow.UpdateUnits"><code class="name flex">
<span>def <span class="ident">UpdateUnits</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to update the layer thickness spinboxes, making sure that
the value in nm corresponds an integer multiple of the lattice parameter,
defined by the monolayer's spinboxes, and vice versa.
This routine is divided in two parts (by the try-except), things that can be
determined before creating a simulation and the ones that depend on the lattice
parameter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def UpdateUnits(self):
    &#34;&#34;&#34;
    This function is used to update the layer thickness spinboxes, making sure that
    the value in nm corresponds an integer multiple of the lattice parameter,
    defined by the monolayer&#39;s spinboxes, and vice versa.
    This routine is divided in two parts (by the try-except), things that can be
    determined before creating a simulation and the ones that depend on the lattice
    parameter.
    &#34;&#34;&#34;
    # If the user prefers to use nanometers instead of monolayers:
    if self.adv_nm_layers_chkbx.checkState():
        # Changes the suffix of the spinboxes
        self.auto_step_spb.setSuffix(&#34; nm&#34;)
        self.auto_final_spb.setSuffix(&#34; nm&#34;)
        self.auto_init_spb.setSuffix(&#34; nm&#34;)
    else:  # If the user is using monolayers
        # Changes the suffix of the spinboxes
        self.auto_step_spb.setSuffix(&#34; ML&#34;)
        self.auto_final_spb.setSuffix(&#34; ML&#34;)
        self.auto_init_spb.setSuffix(&#34; ML&#34;)

    # The lattice parameter is only defined after a simulation was created.
    try:  # Gets the current simulation and the value of the lattice parameter
        sim = self.sim_list[self.simulation_cbox.currentIndex()]
        ml = sim.latpar / 2.0
    except:
        return

    # Identifies which spinbox was modified (the one which called this function)
    op = self.sender()

    # If the user prefers to use nanometers instead of monolayers:
    if self.adv_nm_layers_chkbx.checkState():
        # Disable the ml spinboxes, so that the user cannot interact with them
        self.barrier_ml_spb.setEnabled(False)
        self.well_ml_spb.setEnabled(False)
        self.sim_dx_ml_spb.setEnabled(False)
        # Enable the nm spinboxes
        self.barrier_nm_spb.setEnabled(True)
        self.well_nm_spb.setEnabled(True)
        self.sim_dx_nm_spb.setEnabled(True)

        # Set the value of the monolayers spinboxes, base on the nm values (converted to meters)
        # if op == self.barrier_nm_spb:
        self.barrier_ml_spb.setValue(
            np.round(self.barrier_nm_spb.value() * NM / ml, 3)
        )
        # if op == self.well_nm_spb:
        self.well_ml_spb.setValue(np.round(self.well_nm_spb.value() * NM / ml, 3))
        self.sim_dx_ml_spb.setValue(
            np.round(self.sim_dx_nm_spb.value() * NM / ml, 3)
        )

    # If the user is using monolayers
    else:
        # Enable the ml spinboxes, so that the user can interact with them
        self.barrier_ml_spb.setEnabled(True)
        self.well_ml_spb.setEnabled(True)
        self.sim_dx_ml_spb.setEnabled(True)
        # Disable the nm spinboxes
        self.barrier_nm_spb.setEnabled(False)
        self.well_nm_spb.setEnabled(False)
        self.sim_dx_nm_spb.setEnabled(False)
        # if op == self.barrier_ml_spb:
        # lp is in meters, converts to nm
        self.barrier_nm_spb.setValue(self.barrier_ml_spb.value() * ml / NM)
        # if op == self.well_ml_spb:
        self.well_nm_spb.setValue(self.well_ml_spb.value() * ml / NM)
        self.sim_dx_nm_spb.setValue(self.sim_dx_ml_spb.value() * ml / NM)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="e-mulate.NewSimWindow"><code class="flex name class">
<span>class <span class="ident">NewSimWindow</span></span>
<span>(</span><span>current_number, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Window that allows the user to create a new simulation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NewSimWindow(QWidget):
    &#34;&#34;&#34;
    Window that allows the user to create a new simulation.
    &#34;&#34;&#34;

    signal_new_title = pyqtSignal(str, str)
    signal_updated_current_number = pyqtSignal(int)

    def __init__(self, current_number, parent=None):
        super(NewSimWindow, self).__init__(parent)
        uic.loadUi(
            os.path.join(os.path.dirname(__file__), &#34;GUI&#34;, &#34;New_Simulation.ui&#34;), self
        )

        self.ConnectSignals()
        # Load the information from the configuration file to the UI and updates other values
        self.InterfaceSetup(current_number)
        # Creates a timer to update the texts
        self.CreateInterfaceTimer()

    def InterfaceSetup(self, current_number):
        &#34;&#34;&#34;
        Fills the interface with the updated values.
        &#34;&#34;&#34;
        # Set the options in the comboboxes
        options = [&#34;No&#34;, &#34;Before Title&#34;, &#34;After Title&#34;]
        for option in options:
            self.title_number_cbox.addItem(option)
            self.title_date_cbox.addItem(option)
            self.title_time_cbox.addItem(option)
            self.title_materials_cbox.addItem(option)

        # Loads the available materias from the file
        self.mat = configparser.ConfigParser()
        self.mat.read(
            os.path.join(os.path.dirname(os.path.realpath(__file__)), &#34;materials.data&#34;)
        )

        for pair in self.mat.sections():
            self.materials_cbox.addItem(pair)

        # Updates the current simulation number
        self.number_spb.setValue(current_number)

    def ConnectSignals(self):
        &#34;&#34;&#34;
        Definition of the interaction between button clicks, signals and actions.
        &#34;&#34;&#34;
        # Set the focus to the title line, so that the user can type right away
        self.title_line.setFocus()

        # The window might be closed in three ways:
        # pressing enter while the title_line is selected
        self.title_line.returnPressed.connect(self.SetTitle)
        # or pressing enter while it&#39;s selected
        self.create_simulation_btn.setDefault(True)
        # or by clicking the create_simulation button
        self.create_simulation_btn.clicked.connect(self.SetTitle)

        # When the user changes the simulation number, the main window gets a signal
        # If the value in the number spinbox was modified, update the self.current_number
        self.number_spb.valueChanged.connect(self.UpdatedCurrentNumber)

    def UpdatedCurrentNumber(self):
        self.current_number = self.number_spb.value()
        self.signal_updated_current_number.emit(self.number_spb.value())

    def CreateInterfaceTimer(self):
        &#34;&#34;&#34;
        Creates a QTimer that regularly updates the interface, in order to keep track of the current
        time.
        &#34;&#34;&#34;
        self.UpdateTexts()  # Runs the function that updates the title once just to keep the ui tidy
        self.txt_timer = QTimer()
        txt_update_interval = 200  # ms
        self.txt_timer.start(txt_update_interval)
        self.txt_timer.timeout.connect(self.UpdateTexts)

    def SetTitle(self):
        &#34;&#34;&#34;
        When the user clicks the button or press Enter, this function will get the title, the
        current selection of materials and emit a signal with this information, so that the main
        window can create a new simulation.
        &#34;&#34;&#34;
        title = self.ComposeTitle()
        materials = self.materials_cbox.currentText()
        self.signal_new_title.emit(title, materials)

    def UpdateTexts(self):
        &#34;&#34;&#34;
        Keeps the info shown on the interface updated
        &#34;&#34;&#34;
        self.number_spb.setValue(self.current_number)
        now = time.localtime()
        self.date_text.setText(time.strftime(&#34;%Y-%m-%d&#34;, now))
        self.time_text.setText(time.strftime(&#34;%Hh%Mm%Ss&#34;, now))
        self.materials_text.setText(self.materials_cbox.currentText())
        self.name_preview_text.setText(self.ComposeTitle())

    def ComposeTitle(self):
        &#34;&#34;&#34;
        Function that reads the options defined on the interface and returns the title based on that
        The items are inserted in the order the comboboxes appear:
        Number Date Time Material Title Number Date Time Material
        &#34;&#34;&#34;
        title = self.title_line.text()
        now = time.localtime()

        if self.title_materials_cbox.currentIndex() == 1:
            title = self.materials_cbox.currentText() + &#34; &#34; + title
        if self.title_time_cbox.currentIndex() == 1:
            title = time.strftime(&#34;%Hh%Mm%Ss&#34;, now) + &#34; &#34; + title
        if self.title_date_cbox.currentIndex() == 1:
            title = time.strftime(&#34;%Y-%m-%d&#34;, now) + &#34; &#34; + title
        if self.title_number_cbox.currentIndex() == 1:
            title = str(self.number_spb.value()) + &#34; &#34; + title

        # Just in case there are trailing spaces due to the title being empty
        title = title.rstrip()

        if self.title_materials_cbox.currentIndex() == 2:
            title += &#34; &#34; + self.materials_cbox.currentText()
        if self.title_time_cbox.currentIndex() == 2:
            title += &#34; &#34; + time.strftime(&#34;%Hh%Mm%Ss&#34;, now)
        if self.title_date_cbox.currentIndex() == 2:
            title += &#34; &#34; + time.strftime(&#34;%Y-%m-%d&#34;, now)
        if self.title_number_cbox.currentIndex() == 2:
            title += &#34; &#34; + str(self.number_spb.value())

        # Just in case there are leading spaces due to the title being empty
        title = title.lstrip()

        return title</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="e-mulate.NewSimWindow.ComposeTitle"><code class="name flex">
<span>def <span class="ident">ComposeTitle</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that reads the options defined on the interface and returns the title based on that
The items are inserted in the order the comboboxes appear:
Number Date Time Material Title Number Date Time Material</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ComposeTitle(self):
    &#34;&#34;&#34;
    Function that reads the options defined on the interface and returns the title based on that
    The items are inserted in the order the comboboxes appear:
    Number Date Time Material Title Number Date Time Material
    &#34;&#34;&#34;
    title = self.title_line.text()
    now = time.localtime()

    if self.title_materials_cbox.currentIndex() == 1:
        title = self.materials_cbox.currentText() + &#34; &#34; + title
    if self.title_time_cbox.currentIndex() == 1:
        title = time.strftime(&#34;%Hh%Mm%Ss&#34;, now) + &#34; &#34; + title
    if self.title_date_cbox.currentIndex() == 1:
        title = time.strftime(&#34;%Y-%m-%d&#34;, now) + &#34; &#34; + title
    if self.title_number_cbox.currentIndex() == 1:
        title = str(self.number_spb.value()) + &#34; &#34; + title

    # Just in case there are trailing spaces due to the title being empty
    title = title.rstrip()

    if self.title_materials_cbox.currentIndex() == 2:
        title += &#34; &#34; + self.materials_cbox.currentText()
    if self.title_time_cbox.currentIndex() == 2:
        title += &#34; &#34; + time.strftime(&#34;%Hh%Mm%Ss&#34;, now)
    if self.title_date_cbox.currentIndex() == 2:
        title += &#34; &#34; + time.strftime(&#34;%Y-%m-%d&#34;, now)
    if self.title_number_cbox.currentIndex() == 2:
        title += &#34; &#34; + str(self.number_spb.value())

    # Just in case there are leading spaces due to the title being empty
    title = title.lstrip()

    return title</code></pre>
</details>
</dd>
<dt id="e-mulate.NewSimWindow.ConnectSignals"><code class="name flex">
<span>def <span class="ident">ConnectSignals</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Definition of the interaction between button clicks, signals and actions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConnectSignals(self):
    &#34;&#34;&#34;
    Definition of the interaction between button clicks, signals and actions.
    &#34;&#34;&#34;
    # Set the focus to the title line, so that the user can type right away
    self.title_line.setFocus()

    # The window might be closed in three ways:
    # pressing enter while the title_line is selected
    self.title_line.returnPressed.connect(self.SetTitle)
    # or pressing enter while it&#39;s selected
    self.create_simulation_btn.setDefault(True)
    # or by clicking the create_simulation button
    self.create_simulation_btn.clicked.connect(self.SetTitle)

    # When the user changes the simulation number, the main window gets a signal
    # If the value in the number spinbox was modified, update the self.current_number
    self.number_spb.valueChanged.connect(self.UpdatedCurrentNumber)</code></pre>
</details>
</dd>
<dt id="e-mulate.NewSimWindow.CreateInterfaceTimer"><code class="name flex">
<span>def <span class="ident">CreateInterfaceTimer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a QTimer that regularly updates the interface, in order to keep track of the current
time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CreateInterfaceTimer(self):
    &#34;&#34;&#34;
    Creates a QTimer that regularly updates the interface, in order to keep track of the current
    time.
    &#34;&#34;&#34;
    self.UpdateTexts()  # Runs the function that updates the title once just to keep the ui tidy
    self.txt_timer = QTimer()
    txt_update_interval = 200  # ms
    self.txt_timer.start(txt_update_interval)
    self.txt_timer.timeout.connect(self.UpdateTexts)</code></pre>
</details>
</dd>
<dt id="e-mulate.NewSimWindow.InterfaceSetup"><code class="name flex">
<span>def <span class="ident">InterfaceSetup</span></span>(<span>self, current_number)</span>
</code></dt>
<dd>
<div class="desc"><p>Fills the interface with the updated values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def InterfaceSetup(self, current_number):
    &#34;&#34;&#34;
    Fills the interface with the updated values.
    &#34;&#34;&#34;
    # Set the options in the comboboxes
    options = [&#34;No&#34;, &#34;Before Title&#34;, &#34;After Title&#34;]
    for option in options:
        self.title_number_cbox.addItem(option)
        self.title_date_cbox.addItem(option)
        self.title_time_cbox.addItem(option)
        self.title_materials_cbox.addItem(option)

    # Loads the available materias from the file
    self.mat = configparser.ConfigParser()
    self.mat.read(
        os.path.join(os.path.dirname(os.path.realpath(__file__)), &#34;materials.data&#34;)
    )

    for pair in self.mat.sections():
        self.materials_cbox.addItem(pair)

    # Updates the current simulation number
    self.number_spb.setValue(current_number)</code></pre>
</details>
</dd>
<dt id="e-mulate.NewSimWindow.SetTitle"><code class="name flex">
<span>def <span class="ident">SetTitle</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>When the user clicks the button or press Enter, this function will get the title, the
current selection of materials and emit a signal with this information, so that the main
window can create a new simulation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SetTitle(self):
    &#34;&#34;&#34;
    When the user clicks the button or press Enter, this function will get the title, the
    current selection of materials and emit a signal with this information, so that the main
    window can create a new simulation.
    &#34;&#34;&#34;
    title = self.ComposeTitle()
    materials = self.materials_cbox.currentText()
    self.signal_new_title.emit(title, materials)</code></pre>
</details>
</dd>
<dt id="e-mulate.NewSimWindow.UpdateTexts"><code class="name flex">
<span>def <span class="ident">UpdateTexts</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Keeps the info shown on the interface updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def UpdateTexts(self):
    &#34;&#34;&#34;
    Keeps the info shown on the interface updated
    &#34;&#34;&#34;
    self.number_spb.setValue(self.current_number)
    now = time.localtime()
    self.date_text.setText(time.strftime(&#34;%Y-%m-%d&#34;, now))
    self.time_text.setText(time.strftime(&#34;%Hh%Mm%Ss&#34;, now))
    self.materials_text.setText(self.materials_cbox.currentText())
    self.name_preview_text.setText(self.ComposeTitle())</code></pre>
</details>
</dd>
<dt id="e-mulate.NewSimWindow.UpdatedCurrentNumber"><code class="name flex">
<span>def <span class="ident">UpdatedCurrentNumber</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def UpdatedCurrentNumber(self):
    self.current_number = self.number_spb.value()
    self.signal_updated_current_number.emit(self.number_spb.value())</code></pre>
</details>
</dd>
<dt id="e-mulate.NewSimWindow.signal_new_title"><code class="name flex">
<span>def <span class="ident">signal_new_title</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>pyqtSignal(*types, name: str = &hellip;, revision: int = &hellip;, arguments: Sequence = &hellip;) -&gt; PYQT_SIGNAL</p>
<p>types is normally a sequence of individual types.
Each type is either a
type object or a string that is the name of a C++ type.
Alternatively
each type could itself be a sequence of types each describing a different
overloaded signal.
name is the optional C++ name of the signal.
If it is not specified then
the name of the class attribute that is bound to the signal is used.
revision is the optional revision of the signal that is exported to QML.
If it is not specified then 0 is used.
arguments is the optional sequence of the names of the signal's arguments.</p></div>
</dd>
<dt id="e-mulate.NewSimWindow.signal_updated_current_number"><code class="name flex">
<span>def <span class="ident">signal_updated_current_number</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>pyqtSignal(*types, name: str = &hellip;, revision: int = &hellip;, arguments: Sequence = &hellip;) -&gt; PYQT_SIGNAL</p>
<p>types is normally a sequence of individual types.
Each type is either a
type object or a string that is the name of a C++ type.
Alternatively
each type could itself be a sequence of types each describing a different
overloaded signal.
name is the optional C++ name of the signal.
If it is not specified then
the name of the class attribute that is bound to the signal is used.
revision is the optional revision of the signal that is exported to QML.
If it is not specified then 0 is used.
arguments is the optional sequence of the names of the signal's arguments.</p></div>
</dd>
</dl>
</dd>
<dt id="e-mulate.RenameSimWindow"><code class="flex name class">
<span>class <span class="ident">RenameSimWindow</span></span>
<span>(</span><span>sim, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Window that is shown when the user renames or copies a simulation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RenameSimWindow(QWidget):
    &#34;&#34;&#34;
    Window that is shown when the user renames or copies a simulation
    &#34;&#34;&#34;

    signal_renamed = pyqtSignal()

    def __init__(self, sim, parent=None):
        super(RenameSimWindow, self).__init__(parent)
        # uic.loadUi(os.path.join(os.getcwd(), &#34;GUI&#34;, &#34;Sobre_Gui.ui&#34;), self)
        uic.loadUi(
            os.path.join(os.path.dirname(__file__), &#34;GUI&#34;, &#34;RenameSimulation.ui&#34;), self
        )
        self.rename_btn.clicked.connect(lambda: self.Rename(sim))
        # Set the focus to the title line, so that the user can type right away
        self.title_line.setFocus()
        # The window might be closed in three ways:
        # pressing enter while the title_line is selected
        self.title_line.returnPressed.connect(lambda: self.Rename(sim))
        # or pressing enter while it&#39;s selected
        self.rename_btn.setDefault(True)
        # or by clicking the create_simulation button
        self.rename_btn.clicked.connect(lambda: self.Rename(sim))

        self.title_line.setText(sim.title)

    def Rename(self, sim):
        &#34;&#34;&#34;
        Function called when the user clicks on the &#34;rename&#34; button. Renames the title of sim.
        &#34;&#34;&#34;
        # Gets the string from the text box
        title = self.title_line.text()
        # Just in case there are leading spaces due to the title being empty
        sim.title = title.lstrip()
        self.signal_renamed.emit()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="e-mulate.RenameSimWindow.Rename"><code class="name flex">
<span>def <span class="ident">Rename</span></span>(<span>self, sim)</span>
</code></dt>
<dd>
<div class="desc"><p>Function called when the user clicks on the "rename" button. Renames the title of sim.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Rename(self, sim):
    &#34;&#34;&#34;
    Function called when the user clicks on the &#34;rename&#34; button. Renames the title of sim.
    &#34;&#34;&#34;
    # Gets the string from the text box
    title = self.title_line.text()
    # Just in case there are leading spaces due to the title being empty
    sim.title = title.lstrip()
    self.signal_renamed.emit()</code></pre>
</details>
</dd>
<dt id="e-mulate.RenameSimWindow.signal_renamed"><code class="name flex">
<span>def <span class="ident">signal_renamed</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>pyqtSignal(*types, name: str = &hellip;, revision: int = &hellip;, arguments: Sequence = &hellip;) -&gt; PYQT_SIGNAL</p>
<p>types is normally a sequence of individual types.
Each type is either a
type object or a string that is the name of a C++ type.
Alternatively
each type could itself be a sequence of types each describing a different
overloaded signal.
name is the optional C++ name of the signal.
If it is not specified then
the name of the class attribute that is bound to the signal is used.
revision is the optional revision of the signal that is exported to QML.
If it is not specified then 0 is used.
arguments is the optional sequence of the names of the signal's arguments.</p></div>
</dd>
</dl>
</dd>
<dt id="e-mulate.SobreWindow"><code class="flex name class">
<span>class <span class="ident">SobreWindow</span></span>
<span>(</span><span>parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>About window</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SobreWindow(QMainWindow):
    &#34;&#34;&#34;
    About window
    &#34;&#34;&#34;

    def __init__(self, parent=None):
        super(SobreWindow, self).__init__(parent)
        # uic.loadUi(os.path.join(os.getcwd(), &#34;GUI&#34;, &#34;Sobre_Gui.ui&#34;), self)
        uic.loadUi(os.path.join(os.path.dirname(__file__), &#34;GUI&#34;, &#34;Sobre_Gui.ui&#34;), self)
        self.webpage_btn.clicked.connect(self.webpage)
        self.Ok_btn.clicked.connect(self.close)

    def webpage(self):
        webbrowser.open(&#34;http://www.if.ufrj.br/~gpenello/&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="e-mulate.SobreWindow.webpage"><code class="name flex">
<span>def <span class="ident">webpage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def webpage(self):
    webbrowser.open(&#34;http://www.if.ufrj.br/~gpenello/&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="e-mulate.MainWindow" href="#e-mulate.MainWindow">MainWindow</a></code></h4>
<ul class="">
<li><code><a title="e-mulate.MainWindow.Campo" href="#e-mulate.MainWindow.Campo">Campo</a></code></li>
<li><code><a title="e-mulate.MainWindow.ChooseOutputFolder" href="#e-mulate.MainWindow.ChooseOutputFolder">ChooseOutputFolder</a></code></li>
<li><code><a title="e-mulate.MainWindow.ClearAbsPlot" href="#e-mulate.MainWindow.ClearAbsPlot">ClearAbsPlot</a></code></li>
<li><code><a title="e-mulate.MainWindow.ClearDataTable" href="#e-mulate.MainWindow.ClearDataTable">ClearDataTable</a></code></li>
<li><code><a title="e-mulate.MainWindow.ClearMaterialData" href="#e-mulate.MainWindow.ClearMaterialData">ClearMaterialData</a></code></li>
<li><code><a title="e-mulate.MainWindow.ClearPhotocurrentPlot" href="#e-mulate.MainWindow.ClearPhotocurrentPlot">ClearPhotocurrentPlot</a></code></li>
<li><code><a title="e-mulate.MainWindow.ClearSimPlot" href="#e-mulate.MainWindow.ClearSimPlot">ClearSimPlot</a></code></li>
<li><code><a title="e-mulate.MainWindow.ClearStructureTable" href="#e-mulate.MainWindow.ClearStructureTable">ClearStructureTable</a></code></li>
<li><code><a title="e-mulate.MainWindow.ClearTransPlot" href="#e-mulate.MainWindow.ClearTransPlot">ClearTransPlot</a></code></li>
<li><code><a title="e-mulate.MainWindow.CloseRenameWindow" href="#e-mulate.MainWindow.CloseRenameWindow">CloseRenameWindow</a></code></li>
<li><code><a title="e-mulate.MainWindow.ConnectSignals" href="#e-mulate.MainWindow.ConnectSignals">ConnectSignals</a></code></li>
<li><code><a title="e-mulate.MainWindow.CopySimulation" href="#e-mulate.MainWindow.CopySimulation">CopySimulation</a></code></li>
<li><code><a title="e-mulate.MainWindow.CreateOutputFolder" href="#e-mulate.MainWindow.CreateOutputFolder">CreateOutputFolder</a></code></li>
<li><code><a title="e-mulate.MainWindow.CreatePlots" href="#e-mulate.MainWindow.CreatePlots">CreatePlots</a></code></li>
<li><code><a title="e-mulate.MainWindow.CreateSimulation" href="#e-mulate.MainWindow.CreateSimulation">CreateSimulation</a></code></li>
<li><code><a title="e-mulate.MainWindow.CreatedNewSimulation" href="#e-mulate.MainWindow.CreatedNewSimulation">CreatedNewSimulation</a></code></li>
<li><code><a title="e-mulate.MainWindow.DeleteSimulation" href="#e-mulate.MainWindow.DeleteSimulation">DeleteSimulation</a></code></li>
<li><code><a title="e-mulate.MainWindow.FillMaterialData" href="#e-mulate.MainWindow.FillMaterialData">FillMaterialData</a></code></li>
<li><code><a title="e-mulate.MainWindow.InitializeDataTable" href="#e-mulate.MainWindow.InitializeDataTable">InitializeDataTable</a></code></li>
<li><code><a title="e-mulate.MainWindow.InitializeStructTable" href="#e-mulate.MainWindow.InitializeStructTable">InitializeStructTable</a></code></li>
<li><code><a title="e-mulate.MainWindow.LoadSimulation" href="#e-mulate.MainWindow.LoadSimulation">LoadSimulation</a></code></li>
<li><code><a title="e-mulate.MainWindow.OpenNewSimWindow" href="#e-mulate.MainWindow.OpenNewSimWindow">OpenNewSimWindow</a></code></li>
<li><code><a title="e-mulate.MainWindow.PlotAbsorption" href="#e-mulate.MainWindow.PlotAbsorption">PlotAbsorption</a></code></li>
<li><code><a title="e-mulate.MainWindow.PlotPhotocurrent" href="#e-mulate.MainWindow.PlotPhotocurrent">PlotPhotocurrent</a></code></li>
<li><code><a title="e-mulate.MainWindow.PlotSimResults" href="#e-mulate.MainWindow.PlotSimResults">PlotSimResults</a></code></li>
<li><code><a title="e-mulate.MainWindow.PlotStructure" href="#e-mulate.MainWindow.PlotStructure">PlotStructure</a></code></li>
<li><code><a title="e-mulate.MainWindow.PlotTransmission" href="#e-mulate.MainWindow.PlotTransmission">PlotTransmission</a></code></li>
<li><code><a title="e-mulate.MainWindow.RenameSimulation" href="#e-mulate.MainWindow.RenameSimulation">RenameSimulation</a></code></li>
<li><code><a title="e-mulate.MainWindow.RunAbsorption" href="#e-mulate.MainWindow.RunAbsorption">RunAbsorption</a></code></li>
<li><code><a title="e-mulate.MainWindow.RunAutomation" href="#e-mulate.MainWindow.RunAutomation">RunAutomation</a></code></li>
<li><code><a title="e-mulate.MainWindow.RunPhotocurrent" href="#e-mulate.MainWindow.RunPhotocurrent">RunPhotocurrent</a></code></li>
<li><code><a title="e-mulate.MainWindow.RunSimulation" href="#e-mulate.MainWindow.RunSimulation">RunSimulation</a></code></li>
<li><code><a title="e-mulate.MainWindow.RunTransmission" href="#e-mulate.MainWindow.RunTransmission">RunTransmission</a></code></li>
<li><code><a title="e-mulate.MainWindow.SaveGUIConfigFile" href="#e-mulate.MainWindow.SaveGUIConfigFile">SaveGUIConfigFile</a></code></li>
<li><code><a title="e-mulate.MainWindow.SavePhotocurrentOutput" href="#e-mulate.MainWindow.SavePhotocurrentOutput">SavePhotocurrentOutput</a></code></li>
<li><code><a title="e-mulate.MainWindow.SaveSimOutput" href="#e-mulate.MainWindow.SaveSimOutput">SaveSimOutput</a></code></li>
<li><code><a title="e-mulate.MainWindow.SaveSimulation" href="#e-mulate.MainWindow.SaveSimulation">SaveSimulation</a></code></li>
<li><code><a title="e-mulate.MainWindow.SaveTransmissionOutput" href="#e-mulate.MainWindow.SaveTransmissionOutput">SaveTransmissionOutput</a></code></li>
<li><code><a title="e-mulate.MainWindow.Sobre" href="#e-mulate.MainWindow.Sobre">Sobre</a></code></li>
<li><code><a title="e-mulate.MainWindow.UpdateCurrentNumber" href="#e-mulate.MainWindow.UpdateCurrentNumber">UpdateCurrentNumber</a></code></li>
<li><code><a title="e-mulate.MainWindow.UpdateDataTable" href="#e-mulate.MainWindow.UpdateDataTable">UpdateDataTable</a></code></li>
<li><code><a title="e-mulate.MainWindow.UpdateInterface" href="#e-mulate.MainWindow.UpdateInterface">UpdateInterface</a></code></li>
<li><code><a title="e-mulate.MainWindow.UpdateLayerCount" href="#e-mulate.MainWindow.UpdateLayerCount">UpdateLayerCount</a></code></li>
<li><code><a title="e-mulate.MainWindow.UpdateSimList" href="#e-mulate.MainWindow.UpdateSimList">UpdateSimList</a></code></li>
<li><code><a title="e-mulate.MainWindow.UpdateStructure" href="#e-mulate.MainWindow.UpdateStructure">UpdateStructure</a></code></li>
<li><code><a title="e-mulate.MainWindow.UpdateStructureTable" href="#e-mulate.MainWindow.UpdateStructureTable">UpdateStructureTable</a></code></li>
<li><code><a title="e-mulate.MainWindow.UpdateUnits" href="#e-mulate.MainWindow.UpdateUnits">UpdateUnits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="e-mulate.NewSimWindow" href="#e-mulate.NewSimWindow">NewSimWindow</a></code></h4>
<ul class="">
<li><code><a title="e-mulate.NewSimWindow.ComposeTitle" href="#e-mulate.NewSimWindow.ComposeTitle">ComposeTitle</a></code></li>
<li><code><a title="e-mulate.NewSimWindow.ConnectSignals" href="#e-mulate.NewSimWindow.ConnectSignals">ConnectSignals</a></code></li>
<li><code><a title="e-mulate.NewSimWindow.CreateInterfaceTimer" href="#e-mulate.NewSimWindow.CreateInterfaceTimer">CreateInterfaceTimer</a></code></li>
<li><code><a title="e-mulate.NewSimWindow.InterfaceSetup" href="#e-mulate.NewSimWindow.InterfaceSetup">InterfaceSetup</a></code></li>
<li><code><a title="e-mulate.NewSimWindow.SetTitle" href="#e-mulate.NewSimWindow.SetTitle">SetTitle</a></code></li>
<li><code><a title="e-mulate.NewSimWindow.UpdateTexts" href="#e-mulate.NewSimWindow.UpdateTexts">UpdateTexts</a></code></li>
<li><code><a title="e-mulate.NewSimWindow.UpdatedCurrentNumber" href="#e-mulate.NewSimWindow.UpdatedCurrentNumber">UpdatedCurrentNumber</a></code></li>
<li><code><a title="e-mulate.NewSimWindow.signal_new_title" href="#e-mulate.NewSimWindow.signal_new_title">signal_new_title</a></code></li>
<li><code><a title="e-mulate.NewSimWindow.signal_updated_current_number" href="#e-mulate.NewSimWindow.signal_updated_current_number">signal_updated_current_number</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="e-mulate.RenameSimWindow" href="#e-mulate.RenameSimWindow">RenameSimWindow</a></code></h4>
<ul class="">
<li><code><a title="e-mulate.RenameSimWindow.Rename" href="#e-mulate.RenameSimWindow.Rename">Rename</a></code></li>
<li><code><a title="e-mulate.RenameSimWindow.signal_renamed" href="#e-mulate.RenameSimWindow.signal_renamed">signal_renamed</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="e-mulate.SobreWindow" href="#e-mulate.SobreWindow">SobreWindow</a></code></h4>
<ul class="">
<li><code><a title="e-mulate.SobreWindow.webpage" href="#e-mulate.SobreWindow.webpage">webpage</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>